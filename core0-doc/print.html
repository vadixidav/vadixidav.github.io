<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>UARC core0</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="overview.html"><strong>1.</strong> Overview</a></li><li><a href="architecture.html"><strong>2.</strong> Architecture</a></li><li><ul class="section"><li><a href="architecture/registers.html"><strong>2.1.</strong> Registers</a></li><li><a href="architecture/dstack.html"><strong>2.2.</strong> dstack</a></li><li><a href="architecture/cstack.html"><strong>2.3.</strong> cstack</a></li><li><a href="architecture/lstack.html"><strong>2.4.</strong> lstack</a></li><li><a href="architecture/ifile.html"><strong>2.5.</strong> ifile</a></li><li><a href="architecture/conveyor.html"><strong>2.6.</strong> conveyor</a></li></ul></li><li><a href="instruction_reference.html"><strong>3.</strong> Instruction Reference</a></li><li><ul class="section"><li><a href="instruction_reference/arithmetic.html"><strong>3.1.</strong> Arithmetic</a></li><li><a href="instruction_reference/bit_manipulation.html"><strong>3.2.</strong> Bit Manipulation</a></li><li><a href="instruction_reference/stack_manipulation.html"><strong>3.3.</strong> Stack Manipulation</a></li><li><a href="instruction_reference/memory.html"><strong>3.4.</strong> Memory</a></li><li><a href="instruction_reference/control_flow.html"><strong>3.5.</strong> Control Flow</a></li><li><a href="instruction_reference/uarc.html"><strong>3.6.</strong> UARC</a></li></ul></li><li><a href="uarc.html"><strong>4.</strong> UARC</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">UARC core0</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Overview</h1>
<p>UARC core0 (c0) is the primary general purpose ISA for the UARC standardized core collection. Although it is an ISA, a reference implementation is provided via emulator and SystemVerilog.</p>
<p>This architecture is targeted towards small size and efficiency in shuffling data around across the UARC bus. No floating point instructions are included since it is expected that such algorithms will not run on core0, but will instead be offloaded to another UARC compatible core with floating point support. Due to the nature of UARC, it is possible to implement floating point operations using a coprocessor that connects over the UARC bus if desired.</p>
<p>It is important to note that although this core can be used for an OS that spreads cross multiple UARC cores, it is not intended to be the target of user space applications, except where those applications need to shuffle data around between UARC cores or only require integer arithmetic. c0 demonstrates the UARC principle while simultaneously acting as a mediator of data between UARC cores.</p>
<p>c0's ISA is designed to use whatever word size is required, but it is intended to be used as a 32-bit architecture.</p>
<h1>Architecture</h1>
<h3>Status</h3>
<table><thead><tr><td>Symbol</td><td>Purpose</td></tr></thead>
<tr><td><code>c</code></td><td>Carry bit</td></tr>
<tr><td><code>o</code></td><td>Overflow bit</td></tr>
</table>
<p>c0 is a stack machine, meaning that all parameters are implicit and all destinations are implicit except for stack manipulation and memory access. For comparison, belt machines have an implicit destination and register machines (the most common) have explicit parameters and destination. This means that for many instructions, a stack machine's instruction is entirely composed of an opcode with no extra fields. For c0, half of all instructions only have an opcode field, but the other half (stack manipulation instructions) the instruction contains an opcode and location field. This means that c0 has <a href="instruction_reference.html">two instruction formats</a>.</p>
<p>Since no task switching is required in c0, it is not necessary to be concerned with the amount of state elements in the architecture, except where those elements require random access. Due to this, several stacks are present in the architecture, aside from the main stack on which most of the processor occurs: the <a href="architecture/dstack.html">dstack</a>. For instance, the architecture also has a dedicated <a href="architecture/cstack.html">call stack</a> so that parameters can be passed orderly to a called routine and be consumed without worrying about the return address. A zero-overhead loop unit is also present that allows automatic conditional branching back to the beginning of the inner-most loop. The stack that contains the various loop parameters is called the <a href="architecture/lstack.html">loop stack</a>.</p>
<p>Not all stacks present in c0 are Last-In First-Out (LIFO). The <a href="architecture/dstack.html">dstack</a> itself has dedicated copy and rotate instructions so that it is possible to copy or move things to the top of the stack. However, the <a href="architecture/dstack.html">dstack</a> copy instruction is intended to allow variables to be computed once and copied into place on the stack however many additional times they are required before the final value is consumed.</p>
<p>Finally, the <a href="architecture/ifile.html">ifile</a> is a register file containing the interrupt address, enable bit, and selection bit that corresponds to each UARC bus present on the core. Each of the interrupts can be individually enabled, disabled, and set. Using the selection mechanism, several addresses can be enabled, disabled, and set simultaneously to avoid wasting time setting up interrupts or sending/receiving messages to/from multiple targets.</p>
<h1>Registers</h1>
<table><thead><tr><td>Name</td><td>Purpose</td></tr></thead>
<tr><td><code>PC</code></td><td>The location of the presently executing instruction</td></tr>
<tr><td><code>DC#</code></td><td>4 locations data can be used and stored in order; also can be made into stacks</td></tr>
<tr><td><code>i</code></td><td>A status bit that conveys if an interrupt has been handled since last checked</td></tr>
<tr><td><code>c</code></td><td>A status bit for arithmetic carry</td></tr>
<tr><td><code>o</code></td><td>A status bit for overflow</td></tr>
</table>
<h1>dstack</h1>
<p>The <strong>dstack</strong> is the primary stack on which all operations take place. This stack is the only stack that can be rotated and copied in one cycle. If the <strong>dstack</strong> is rotated, all elements below the selected element will not shift down, but all elements above it will shift down and the selected element will be placed on the top. If the <strong>dstack</strong> is copied, all elements move down and the copied element is moved to the top.</p>
<p>All elements on the <strong>dstack</strong> are capable of being pushed once, doing nothing, popping once, or popping twice. What happens to the <strong>dstack</strong> is explicitly encoded in the <code>[6:5]</code> bits of the instruction for all instructions for which the <code>[7]</code> bit is <code>0</code>. More importantly, when the stack is rotated or copied, the <code>[5:0]</code> bits are used to encode the location to perform the operation on, which makes it quick for the instruction to be decoded.</p>
<p>The <strong>dstack</strong> is where almost all parameters should be passed into functions and where almost all parameters should be returned from functions. Should a function need to access a loop index explicitly as a constant parameter, it can safely use loop index instructions. Information may also be passed into functions via the status bits. Except when programming manually using assembly, the compiler should not generate code that passes information using any method described above. If the compiler wishes to achieve a speed-up by preserving the DCs across the call, it should be implemented as an inline expansion of the function.</p>
<h1>cstack</h1>
<p>The cstack is a call stack that contains state information required to return from a subroutine call. This includes things such as the PC, the DCs, and if the last call was to an interrupt. The status bits are not preserved in a call. If an interrupt is issued and accepted or either of the call instructions are executed, the cstack will be pushed. Any time a return instruction is executed, the cstack is popped. The cstack should be accessable on a single-cycle notice and thus should exist in processor memory. Because it is only pushed and popped in regular amounts, it deserves a place on-die as its own processor element, though this is not absolutely necessary, and the stack can be spilled into main memory if the need arise.</p>
<table><thead><tr><td>State</td><td>Result on Pop</td></tr></thead>
<tr><td>PC</td><td>Moves PC back to location in caller after the jump/call</td></tr>
<tr><td>DCs</td><td>Restores all DCs to previous locations</td></tr>
<tr><td>interrupt</td><td>Set the <code>i</code> flag to allow checks for interrupt handling</td></tr>
</table>
<h1>lstack</h1>
<p>The <strong>lstack</strong> is a stack with architecture-dependent depth which allows the initialization of loops with zero-overhead. This means that no instruction is wasted checking for loop bounds and no hardware is needed to do branch prediction for loop bounds. Additionally, for the stack processor it means that the loop index is easily obtainable in one instruction for the top four loops. Only the very top loop is checked for its bounds, so the end of a loop that is not on top of the stack should never be encountered.</p>
<h1>ifile</h1>
<p>The ifile is a register file present in c0 that holds state information about each UARC bus connected to the core. The most important thing the ifile holds is if a given port is enabled, has interrupts enabled, and the interrupt address. These three things can all be access through the <a href="instruction_reference/uarc.html">UARC instructions</a> on the c0.</p>
<h1>conveyor</h1>
<p>The conveyor is a processor element found in conveyor machines in which the destination register does not need to be specified, but the parameters do. Since we are embedding the conveyor into a stack processor, operations occasionally consume parameters from the stack in defined positions and place the result on the conveyor so that it can be retrieved when desired. This allows for two things: It allows asynchronous operations to be synchronized when desired and it allows operations that have multiple outputs to provide their results on the stack in the correct positions.</p>
<p>As was stated, the conveyor is capable of synchronizing asynchronous operations. For instance, if a division is executed, the result will be placed onto the conveyor, but that doesn't mean it is completed. If the programmer attempts to read the value from the conveyor, it will trigger a synchronization that waits until the division is complete before reading the value from the conveyor.</p>
<p>Since the conveyor only moves in one direction, when an interrupt is received the conveyor could not be used. This is solved by having an alternate conveyor for interrupts. Since asynchronous operations enter a FIFO queue, operations from before the interrupt is handled may still have to complete before the interrupt can be handled. As these operations finish, they will place their results into the main conveyor's dedicated registers, allowing the interrupt to process asynchronous operations. Some operations use a pipeline and therefore will still finish in constant time, such as multiplication and division. Other operations will have to be waited on, such as random asynchronous memory reads, which can only be processed sequentially, except if they were already in cache.</p>
<h1>Instruction Reference</h1>
<h3>c0 Instruction Formats</h3>
<table><thead><tr><td> Format </td><td> Layout </td></tr></thead>
<tr><td>I (Implicit)</td><td><code>OSSO OOOO</code></td></tr>
<tr><td>L (Loop)</td><td><code>OSSO OOLL</code></td></tr>
<tr><td>D (DC)</td><td><code>OSSO OOLL</code></td></tr>
<tr><td>C (Conveyor)</td><td><code>OSSO LLLL</code></td></tr>
<tr><td>R (Random Access)</td><td><code>OOOL LLLL</code></td></tr>
</table>
<ul>
<li><code>O</code> - Opcode bit</li>
<li><code>S</code> - Stack bit</li>
<li><code>L</code> - Location bit</li>
</ul>
<h3>Stack bits</h3>
<ul>
<li><code>00</code> - The stack is not popped or pushed.</li>
<li><code>01</code> - The stack is pushed once.</li>
<li><code>10</code> - The stack is popped once.</li>
<li><code>11</code> - The stack is popped twice.</li>
</ul>
<h3><code>I</code> - Implicit</h3>
<p>Implicit instructions have no explicit sources or destinations and all can be assumed from state information in the system. Such instructions include <code>add</code>, which takes parameters from the stack and places the result back on the stack.</p>
<h3><code>L</code> - Loop</h3>
<p>Loop instructions allow random read access to the loop index of the top 4 loops in the <a href="architecture/lstack.html">lstack</a>. This means that loops can be nested 4 times and are still able to retrieve the index in one instruction.</p>
<h3><code>D</code> - Data Counter</h3>
<p>Data Counter instructions are instructions that operate on a random one of the 4 available DCs. These can be set, get, read, written, randomly read, and randomly written.</p>
<h3><code>C</code> - Conveyor</h3>
<p>Conveyor instructions allow random read access to the 16 things on the <a href="architecture/conveyor.html">conveyor belt</a>. The things on the conveyor may actually not be present and when accessed, the completion of the operation corresponding to that spot on the conveyor will be synchronized. This allows several asynchronous operations to be linked to different locations on the conveyor and read randomly when they are needed.</p>
<h3><code>R</code> - Random</h3>
<p>For R type instructions, 64 locations can be randomly addressed. This means that 64 places can be copied and rotated on the <a href="architecture/dstack.html">dstack</a>.</p>
<h2>Key</h2>
<ul>
<li><code>WORD</code> - Data word width in use</li>
<li><code>c</code> - Carry bit</li>
<li><code>cv</code> - <a href="architecture/conveyor.html">Conveyor Belt</a></li>
<li><code>dc[0-3]</code> - Data Counters</li>
<li><code>pc</code> - Program Counter</li>
<li><code>iflag</code> - Interrupt Flag</li>
<li><code>i[0-3]</code> - Loop Indices</li>
<li><code>cv[0-F]</code> - <a href="architecture/conveyor.html">Conveyor Belt</a> Values</li>
<li><code>ls</code> - <a href="architecture/lstack.html">lstack</a></li>
<li><code>if</code> - <a href="architecture/ifile.html">ifile</a></li>
<li><code>n..</code> - <code>n</code> anonymous words on the stack</li>
</ul>
<h2>Instruction Listing By Opcode</h2>
<table><thead><tr><td>Op</td><td>Instruction</td><td>dstack</td><td>Side Effects</td></tr></thead>
<tr><td><code>00</code> - <code>03</code></td><td>rread#</td><td><code>a -- mem[dc# + a]</code></td></tr>
<tr></tr>
<tr><td><code>04</code> - <code>07</code></td><td>add#</td><td><code>a -- (a + dc#)</code></td><td>dc# advances; <code>c</code>, <code>o</code></td></tr>
<tr><td><code>08</code></td><td>inc</td><td><code>a -- (a + 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>09</code></td><td>dec</td><td><code>a -- (a - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>0A</code></td><td>carry</td><td><code>v -- (v + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>0B</code></td><td>borrow</td><td><code>v -- (v + c - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>0C</code></td><td>inv</td><td><code>v -- ~v</code></td><td> </td></tr>
<tr><td><code>0D</code></td><td>flush</td><td><code>--</code></td><td>Synchronizes cache flush</td></tr>
<tr><td><code>0E</code></td><td>reads</td><td><code>a -- mem[a]</code></td><td>Synchronous read</td></tr>
<tr><td><code>0F</code></td><td>ret</td><td><code>--</code></td><td>Pops <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>10</code></td><td>ien</td><td><code>--</code></td><td>Enables selected interrupts</td></tr>
<tr><td><code>11</code></td><td>idi</td><td><code>--</code></td><td>Disables all interrupts</td></tr>
<tr><td><code>12</code></td><td>recv</td><td><code>--</code></td><td>Interrupt sync; <code>cv &lt;- bus, v</code></td></tr>
<tr><td><code>13</code></td><td>in</td><td><code>a -- b</code></td><td>Stream in to <code>a</code></td></tr>
<tr><td><code>14</code></td><td>kill</td><td><code>--</code></td><td>Kill all selected cores</td></tr>
<tr><td><code>15</code></td><td>wait</td><td><code>--</code></td><td>Waits for an interrupt before continuing</td></tr>
<tr><td><code>18</code></td><td>calli</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code>; push <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>19</code></td><td>jmpi</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1A</code></td><td>jc</td><td><code>--</code></td><td>if <code>c</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1B</code></td><td>jnc</td><td><code>--</code></td><td>if <code>~c</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1C</code></td><td>jo</td><td><code>--</code></td><td>if <code>o</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1D</code></td><td>jno</td><td><code>--</code></td><td>if <code>~o</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1E</code></td><td>ji</td><td><code>--</code></td><td>if <code>iflag</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1F</code></td><td>jni</td><td><code>--</code></td><td>if <code>~iflag</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>20</code> - <code>2F</code></td><td>cv#</td><td><code>-- cv#</code></td><td>cv# synchronizes</td></tr>
<tr><td><code>30</code> - <code>33</code></td><td>read#</td><td><code>-- mem[dc#]</code></td><td>dc# advances</td></tr>
<tr><td><code>34</code> - <code>37</code></td><td>get#</td><td><code>-- dc#</code></td><td> </td></tr>
<tr><td><code>38</code> - <code>3B</code></td><td>i#</td><td><code>-- i#</code></td><td> </td></tr>
<tr><td><code>3C</code></td><td>p0</td><td><code>-- 0</code></td><td> </td></tr>
<tr><td><code>3D</code></td><td>dup</td><td><code>v -- v v</code></td><td> </td></tr>
<tr><td><code>3E</code></td><td>getp</td><td><code>-- priv</code></td><td>Get UARC privilege</td></tr>
<tr><td><code>3F</code></td><td>geta</td><td><code>-- addr</code></td><td>Get UARC address</td></tr>
<tr><td><code>40</code> - <code>43</code></td><td>write#</td><td><code>v --</code></td><td><code>mem[dc#] = v</code>; dc# advances</td></tr>
<tr><td><code>44</code> - <code>47</code></td><td>setf#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write post-inc</td></tr>
<tr><td><code>48</code> - <code>4B</code></td><td>setb#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write pre-dec</td></tr>
<tr><td><code>4C</code></td><td>add</td><td><code>a b -- (a + b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4D</code></td><td>addc</td><td><code>a b -- (a + b + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4E</code></td><td>sub</td><td><code>a b -- (a - b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4F</code></td><td>subc</td><td><code>a b -- (a - b + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>50</code></td><td>lsl</td><td><code>a b -- (a &lt;&lt; b)</code></td><td><code>o</code></td></tr>
<tr><td><code>51</code></td><td>lsr</td><td><code>a b -- (a &gt;&gt; b)</code></td><td><code>o</code></td></tr>
<tr><td><code>52</code></td><td>csl</td><td><code>a b -- ((a &lt;&lt; b) or (a &gt;&gt; (b - WORD)))</code></td><td> </td></tr>
<tr><td><code>53</code></td><td>csr</td><td><code>a b -- ((a &gt;&gt; b) or (a &lt;&lt; (b - WORD)))</code></td><td> </td></tr>
<tr><td><code>54</code></td><td>asr</td><td><code>a b -- (a &gt;&gt;&gt; b)</code></td><td><code>o</code></td></tr>
<tr><td><code>55</code></td><td>and</td><td><code>a b -- (a &amp; b)</code></td><td> </td></tr>
<tr><td><code>56</code></td><td>or</td><td><code>a b -- (a or b)</code></td><td> </td></tr>
<tr><td><code>57</code></td><td>reada</td><td><code>a --</code></td><td><code>cv &lt;- mem[a]</code></td></tr>
<tr><td><code>58</code></td><td>call</td><td><code>a --</code></td><td><code>pc = a</code>; push <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>59</code></td><td>jmp</td><td><code>a --</code></td><td><code>pc = a</code></td></tr>
<tr><td><code>5A</code></td><td>iset</td><td><code>a --</code></td><td>Set selected interrupt addresses</td></tr>
<tr><td><code>5B</code></td><td>send</td><td><code>v --</code></td><td>Send value to selected buses</td></tr>
<tr><td><code>5C</code></td><td>loopi</td><td><code>n --</code></td><td><code>ls &lt;- n, dc0, 0</code></td></tr>
<tr><td><code>60</code> - <code>63</code></td><td>rwrite#</td><td><code>v a --</code></td><td><code>mem[dc# + a] = v</code></td></tr>
<tr><td><code>64</code></td><td>write</td><td><code>v a --</code></td><td><code>mem[a] = v</code></td></tr>
<tr><td><code>65</code></td><td>jeq</td><td><code>a b --</code></td><td>if <code>a == b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>66</code></td><td>jne</td><td><code>a b --</code></td><td>if <code>a != b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>67</code></td><td>les</td><td><code>a b --</code></td><td>if <code>a &lt; b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>68</code></td><td>leq</td><td><code>a b --</code></td><td>if <code>a &lt;= b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>69</code></td><td>lesu</td><td><code>a b --</code></td><td>if <code>a &lt; b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>6A</code></td><td>lequ</td><td><code>a b --</code></td><td>if <code>a &lt;= b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>6B</code></td><td>out</td><td><code>n a --</code></td><td>Stream n words to buses from a</td></tr>
<tr><td><code>6C</code></td><td>seb</td><td><code>m s --</code></td><td>Clear ifile and set register <code>s</code> to <code>m</code></td></tr>
<tr><td><code>6D</code></td><td>slb</td><td><code>m s --</code></td><td>Ors <code>m</code> with register <code>s</code> of ifile</td></tr>
<tr><td><code>6E</code></td><td>mul</td><td><code>a b --</code></td><td><code>cv &lt;- low(a * b), high(a * b)</code></td></tr>
<tr><td><code>6F</code></td><td>mulu</td><td><code>a b --</code></td><td><code>cv &lt;- low(a * b), high(a * b)</code></td></tr>
<tr><td><code>70</code></td><td>div</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
<tr><td><code>71</code></td><td>divu</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
<tr><td><code>72</code></td><td>loop</td><td><code>n e --</code></td><td><code>ls &lt;- n, e, 0</code></td></tr>
<tr><td><code>73</code></td><td>setp</td><td><code>priv addr --</code></td><td>Sets UARC permission delegation</td></tr>
<tr><td><code>80</code> - <code>BF</code></td><td>rot#</td><td><code>v (# + 1).. -- (# + 1).. v</code></td><td> </td></tr>
<tr><td><code>C0</code> - <code>FF</code></td><td>copy#</td><td><code>v (# + 1).. -- v (# + 1).. v</code></td><td> </td></tr>
</table>
<h1>Arithmetic Instructions</h1>
<h2><code>add#</code></h2>
<p><code>a -- (a + dc#)</code></p>
<h4>Description</h4>
<p><code>add#</code> adds the top of the <a href="architecture/dstack.html">dstack</a> with the immediate value from <code>dc#</code>. The <code>o</code> and <code>c</code> bits are set, but not consumed. <code>dc#</code> is incremented.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + dc#)[WORD]</code></li>
<li><code>o = (a[WORD - 1] ^ dc#[WORD - 1]) ? 0 : a[WORD - 1] ^ (a + dc#)[WORD - 1]</code></li>
</ul>
<hr />
<h2><code>inc</code></h2>
<p><code>a -- (a + 1)</code></p>
<h4>Description</h4>
<p><code>inc</code> increments the top of the <a href="architecture/dstack.html">dstack</a> by 1. The overflow and carry bits are set, but not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + 1 == 0)</code></li>
<li><code>o = (a + 1 == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>h7FFFFFFF inc
</code></pre>
<ul>
<li><code>( -- h80000000)</code></li>
<li><code>o</code> is set to 1 because a positive number became negative by wrapping</li>
<li><code>c</code> is set to 0</li>
</ul>
<hr />
<h2><code>dec</code></h2>
<p><code>a -- (a + 1)</code></p>
<h4>Description</h4>
<p><code>dec</code> decrements the top of the <a href="architecture/dstack.html">dstack</a> by 1. The overflow and carry bits are set, but not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a - 1 != ~0)</code></li>
<li><code>o = (a == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 dec
</code></pre>
<ul>
<li><code>( -- -1)</code></li>
<li><code>o</code> is set to 0 because no overflow occurred</li>
<li><code>c</code> is set to 1 because a borrow was incurred</li>
</ul>
<hr />
<h2><code>carry</code></h2>
<p><code>a -- (a + c)</code></p>
<h4>Description</h4>
<p><code>carry</code> is used when the carry bit needs to be accumulated to a more significant word after a less significant operation. It affects the <code>o</code> and <code>c</code> similarly to <code>inc</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = c == 1 &amp;&amp; (a + c == 0)</code></li>
<li><code>o = c == 1 &amp;&amp; (a == -1)</code></li>
</ul>
<h4>Examples</h4>
<pre><code>~0 inc
0 carry
</code></pre>
<ul>
<li><code>( -- 0 1)</code></li>
<li><code>c</code> is set to 0</li>
<li><code>o</code> is set to 0</li>
</ul>
<hr />
<h2><code>borrow</code></h2>
<p><code>a -- (a + c - 1)</code></p>
<h4>Description</h4>
<p><code>borrow</code> is used when a borrow must be applied to a more significant word after a less significant operation. It affects the <code>o</code> and <code>c</code> bits similarly to <code>dec</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = c == 1 || (a - 1 != ~0)</code></li>
<li><code>o = c == 1 || (a == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 dec
1 borrow
</code></pre>
<ul>
<li><code>( -- 0 0)</code></li>
<li><code>c</code> is set to 0</li>
<li><code>o</code> is set to 0</li>
</ul>
<hr />
<h2><code>add</code></h2>
<p><code>a b -- (a + b)</code></p>
<h4>Description</h4>
<p><code>add</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them. The carry bit is set by this instruction, but is not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + b)[WORD]</code></li>
<li><code>o = (a[WORD - 1] ^ b[WORD - 1]) ? 0 : a[WORD - 1] ^ (a + b)[WORD - 1]</code></li>
</ul>
<h4>Examples</h4>
<pre><code>2 3 add
</code></pre>
<ul>
<li><code>( -- 5)</code></li>
<li>Carry is set to 0</li>
</ul>
<hr />
<h2><code>addc</code></h2>
<p><code>a b -- (a + b + c)</code></p>
<h4>Description</h4>
<p><code>addc</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them with <code>c</code>. Unlike <code>add</code>, <code>addc</code> consumes the carry, so ensure it is correctly set before issuing this instruction.</p>
<h4>Side Effects</h4>
<p><code>c = (a + b)[WORD]</code></p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 h80000000 add
0 0 addc
</code></pre>
<ul>
<li><code>( -- 0 1)</code></li>
<li>Carry is set to 0</li>
</ul>
<hr />
<h2><code>sub</code></h2>
<p><code>a b -- (a - b)</code></p>
<h4>Description</h4>
<p><code>sub</code> subtracts parameter <code>b</code> from <code>a</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs. The carry bit is not consumed by this instruction.</p>
<h4>Side Effects</h4>
<p><code>c = (a - b)[WORD]</code></p>
<h4>Examples</h4>
<pre><code>2 3 sub
</code></pre>
<ul>
<li><code>( -- -1)</code></li>
<li>Carry is set to 0
<ul>
<li>Which indicates a borrow</li>
</ul>
</li>
</ul>
<hr />
<h2><code>subc</code></h2>
<p><code>a b -- (a - b + c)</code></p>
<h4>Description</h4>
<p><code>subc</code> subtracts parameter <code>b</code> from <code>a</code> and adds <code>c</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs.</p>
<h4>Side Effects</h4>
<p><code>c = (a - b)[WORD]</code></p>
<h4>Examples</h4>
<pre><code>2 3 sub
1 0 subc
</code></pre>
<ul>
<li><code>( -- -1 0)</code></li>
<li>Carry is set to 1 (indicating no borrow)</li>
</ul>
<hr />
<h2><code>asr</code></h2>
<p><code>a b -- (a &gt;&gt;&gt; b)</code></p>
<h4>Description</h4>
<p><code>asr</code> shifts <code>a</code> by <code>b</code> bits and sign extends the result. If <code>-1</code> is shifted right, it will continue to stay <code>-1</code>, but <code>o</code> will not be set. The <code>o</code> bit is set if any 1 bits are lost in a positive number or 0 bits lost in a negative number.</p>
<h4>Side Effects</h4>
<ul>
<li><code>o</code> is 1 if any significant bits were lost</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 1 asr
</code></pre>
<ul>
<li><code>( -- hC000000)</code></li>
<li><code>o</code> is set to <code>1</code> because <code>0</code> is a significant bit and is lost</li>
</ul>
<hr />
<h2><code>mul</code></h2>
<p><code>a b -- (a * b)</code></p>
<h4>Description</h4>
<p><code>mul</code> multiplies two signed numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The lower <code>WORD</code> and the higher <code>WORD</code> bits (both including a sign bit) are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The lowest <code>WORD</code> and highest <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
<li><code>o</code> is <code>1</code> if any significant bits are placed into the conveyor</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 2 mul cv1 cv0
</code></pre>
<ul>
<li><code>( -- h80000000 hFFFFFFFE)</code></li>
</ul>
<hr />
<h2><code>mulu</code></h2>
<p><code>a b -- (a * b)</code></p>
<h4>Description</h4>
<p><code>mulu</code> multiplies two unsigned numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The lower <code>WORD</code> and higher <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The lowest <code>WORD</code> and highest <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples</h4>
<pre><code>~0 2 mul cv1 cv0
</code></pre>
<ul>
<li><code>( -- ~0 1)</code></li>
</ul>
<hr />
<h2><code>div</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>div</code> divides two signed numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The higher/whole <code>WORD</code> and the lower/fractional <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>. Both the higher and the lower results are signed.</p>
<h4>Side Effects</h4>
<ul>
<li>The higher/whole <code>WORD</code> and lower/fractional <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 2 div cv1 cv0
</code></pre>
<ul>
<li><code>( -- hC0000000 hBFFFFFFF)</code></li>
</ul>
<hr />
<h2><code>divu</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>divu</code> divides two unsigned numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The higher/whole <code>WORD</code> and the lower/fractional <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The higher/whole <code>WORD</code> and lower/fractional <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>~0 2 divu cv1 cv0
</code></pre>
<ul>
<li><code>( -- h7FFFFFFF h80000000)</code></li>
</ul>
<h1>Bit Manipulation</h1>
<h2><code>inv</code></h2>
<p><code>v -- ~v</code></p>
<h4>Description</h4>
<p><code>inv</code> inverts the bits of v.</p>
<h4>Examples</h4>
<pre><code>~0 inv
</code></pre>
<ul>
<li><code>( -- 0)</code></li>
</ul>
<hr />
<h2><code>lsl</code></h2>
<p><code>a b -- (a &lt;&lt; b)</code></p>
<h4>Description</h4>
<p><code>lsl</code> performs a logical shift left. If any <code>1</code> bits are lost in the shift, the <code>o</code> bit is set to <code>1</code>, otherwise <code>0</code>. This operation zero-fills.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>hFFFFFFFF 1 lsl
</code></pre>
<ul>
<li><code>( -- hFFFFFFFE)</code></li>
<li><code>o</code> is set to <code>1</code></li>
</ul>
<hr />
<h2><code>lsr</code></h2>
<p><code>a b -- (a &gt;&gt; b)</code></p>
<h4>Description</h4>
<p><code>lsr</code> performs a logical shift right. If any <code>1</code> bits are lost in the shift, the <code>o</code> bit is set to <code>1</code>, otherwise <code>0</code>. This operation zero-fills.</p>
<h4>Examples</h4>
<pre><code>3 1 lsr
</code></pre>
<ul>
<li><code>( -- 1)</code></li>
<li><code>o</code> is set to <code>1</code></li>
</ul>
<hr />
<h2><code>csl</code></h2>
<p><code>a b -- ((a &lt;&lt; b) or (a &gt;&gt; (b - WORD)))</code></p>
<h4>Description</h4>
<p><code>csl</code> performs a circular shift left. Only the amount of bits needed are used for the shift amount. For example, with a 32-bit <code>WORD</code>, only the least significant <code>5</code> bits are masked out of <code>b</code>.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>hC0000000 1 csl
</code></pre>
<ul>
<li><code>( -- h80000001)</code></li>
</ul>
<hr />
<h2><code>csr</code></h2>
<p><code>a b -- ((a &gt;&gt; b) or (a &lt;&lt; (b - WORD)))</code></p>
<h4>Description</h4>
<p><code>csr</code> performs a circular shift right. Only the amount of bits needed are used for the shift amount. For example, with a 32-bit <code>WORD</code>, only the least significant <code>5</code> bits are masked out of <code>b</code>.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>3 1 csr
</code></pre>
<ul>
<li><code>( -- h80000001)</code></li>
</ul>
<hr />
<h2><code>and</code></h2>
<p><code>a b -- (a &amp; b)</code></p>
<h4>Description</h4>
<p><code>and</code> finds the binary AND of <code>a</code> and <code>b</code>.</p>
<h4>Examples</h4>
<pre><code>5 4 and
</code></pre>
<ul>
<li><code>( -- 4)</code></li>
</ul>
<hr />
<h2><code>or</code></h2>
<p><code>a b -- (a or b)</code></p>
<h4>Description</h4>
<p><code>or</code> finds the binary OR of <code>a</code> and <code>b</code>.</p>
<h4>Examples</h4>
<pre><code>5 2 or
</code></pre>
<ul>
<li><code>( -- 7)</code></li>
</ul>
<h1>Stack Manipulation Instructions</h1>
<h2><code>p0</code></h2>
<p><code>-- 0</code></p>
<h4>Description</h4>
<p><code>p0</code> pushes a <code>0</code> onto the top of the stack. This doesn't theoretically need to exist, but it makes it practically easy for the processor to add a <code>0</code> to the stack on inception to receive the data stream from the inceptor. It also has other uses, such as initializing an accumulator value and comparisons with <code>0</code>.</p>
<hr />
<h2><code>dup</code></h2>
<p><code>v -- v v</code></p>
<h4>Description</h4>
<p><code>dup</code> fills a void where <code>copy#</code> cannot, which is copying the top of the stack. Since <code>copy#</code> and <code>rot#</code> address starting from the element directly under the top of stack, this instruction is dedicated to allow copying the top of the stack.</p>
<hr />
<h2><code>rot#</code></h2>
<p><code>v (# + 1).. -- (# + 1).. v</code></p>
<h4>Description</h4>
<p><code>rot#</code> rotates a value <code>1</code> to <code>32</code> elements deep in the stack to the top of the stack. The value is removed from that location and elements under that value are not shifted in the stack.</p>
<h4>Examples</h4>
<pre><code>1 2 3 rot1
</code></pre>
<ul>
<li><code>( -- 2 3 1)</code></li>
</ul>
<hr />
<h2><code>copy#</code></h2>
<p><code>v (# + 1).. -- v (# + 1).. v</code></p>
<h4>Description</h4>
<p><code>copy#</code> copies a value <code>1</code> to <code>32</code> elements deep in the stack to the top of the stack. This pushes all elements down on the stack.</p>
<h4>Examples</h4>
<pre><code>1 2 3 copy1
</code></pre>
<ul>
<li><code>( -- 1 2 3 1)</code></li>
</ul>
<h1>Memory Instructions</h1>
<h2><code>rread#</code></h2>
<p><code>a -- mem[dc# + a]</code></p>
<h4>Description</h4>
<p><code>rread#</code> performs a random read starting from <code>dc#</code> and indexing by <code>a</code>. The result is returned synchronously to the stack because it is assumed that this value is held in the cache, since memory at a dc is generally cached.</p>
<hr />
<h2><code>flush</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>flush</code> forces all dirty cache to be written to memory before this instruction completes execution.</p>
<h4>Side Effects</h4>
<ul>
<li>Dirty cache is flushed to main memory</li>
</ul>
<h4>Examples</h4>
<pre><code>write flush send
</code></pre>
<ul>
<li><code>(send_val write_val address -- )</code></li>
<li>On a ccNUMA architecture, the other core can now access the value <code>write_val</code> at <code>address</code></li>
<li>The other core is interrupted only after the value has been flushed to memory</li>
</ul>
<hr />
<h2><code>reads</code></h2>
<p><code>a -- mem[a]</code></p>
<h4>Description</h4>
<p><code>reads</code> performs a synchronous read, meaning that this operation does not complete until the value is on the stack. <code>a</code> is an absolute address.</p>
<hr />
<h2><code>read#</code></h2>
<p><code>-- mem[dc#]</code></p>
<h4>Description</h4>
<p><code>read#</code> performs a read directly at <code>dc#</code>. Doing this increments <code>dc#</code> after the read.</p>
<hr />
<h2><code>get#</code></h2>
<p><code>-- dc#</code></p>
<h4>Description</h4>
<p><code>get#</code> places the address dc# is currently pointing to onto the stack. This allows the programmer to manipulate the dc for allocating memory on a stack or advancing the dc between elements in a vector for use with <code>rread#</code>.</p>
<hr />
<h2><code>write#</code></h2>
<p><code>v --</code></p>
<h4>Description</h4>
<p><code>write#</code> performs a write directly at <code>dc#</code>. Doing this advances <code>dc#</code> depending on how it was set. If it was set with <code>setf</code>, then <code>dc#</code> will write and then increment. If it was set with <code>setb</code>, then <code>dc#</code> will decrement and then write. Due to this behavior, using setb allows a dc to be set up as a pushdown stack.</p>
<hr />
<h2><code>setf#</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>setf#</code> sets <code>dc#</code> to <code>a</code>. It also sets <code>dc#</code> to be in post-increment write mode.</p>
<hr />
<h2><code>setb#</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>setf#</code> sets <code>dc#</code> to <code>a</code>. It also sets <code>dc#</code> to be in pre-decrement write mode.</p>
<hr />
<h2><code>reada</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>reada</code> performs an asynchronous read. This means that the value read will not necessarily complete before the next instruction and the result is not put on the stack. Instead, the value is promised in a slot on the <a href="architecture/conveyor.html">conveyor</a>. When this slot is read from, the read is synchronized and the result is placed on the stack.</p>
<h4>Side Effects</h4>
<ul>
<li><code>cv &lt;- mem[a]</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 reada
# Do other stuff here
cv0
</code></pre>
<ul>
<li><code>( -- mem[0])</code></li>
<li>Between <code>reada</code> and <code>cv0</code>, any operations happen while the read is occurring.</li>
</ul>
<hr />
<h2><code>rwrite#</code></h2>
<p><code>v a --</code></p>
<h4>Description</h4>
<p><code>rwrite#</code> performs a random write relative to <code>dc#</code>. This means that <code>mem[dc# + a] = v</code>. This may be cached.</p>
<h4>Side Effects</h4>
<ul>
<li><code>mem[dc# + a] = v</code></li>
</ul>
<hr />
<h2><code>write</code></h2>
<p><code>v a --</code></p>
<h4>Description</h4>
<p><code>write</code> performs a random write. This means that <code>mem[a] = v</code>. This may be cached.</p>
<h4>Side Effects</h4>
<ul>
<li><code>mem[a] = v</code></li>
</ul>
<h1>Control Flow</h1>
<h2><code>ret</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ret</code> returns from a subroutine call. It pops the <a href="architecture/cstack.html">cstack</a>, moving the PC and DCs back to the position it was at in the caller to continue execution. This instruction returns from interrupts as well as normal subroutines, since an interrupt is a simulated subroutine call. Using <code>ret</code> in an interrupt also allows more interrupts to be serviced unless they are explicitly disabled in the interrupt.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is popped
<ul>
<li>DCs are returned to their previous values</li>
<li>PC is returned to its previous value</li>
<li>If this is the initial subroutine of an interrupt
<ul>
<li>It is finished servicing</li>
<li>The interrupt <a href="architecture/conveyor.html">conveyor</a> is replaced with the normal <a href="architecture/conveyor.html">conveyor</a></li>
<li>The <code>i</code> bit is set</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>Notes</h4>
<ul>
<li>The <a href="architecture/lstack.html">lstack</a> is NOT returned to its previous state.</li>
</ul>
<h4>Examples</h4>
<pre><code>subr calli
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<pre><code>subr jumpi

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>A more efficient version of the previous example by utilizing tail-call elimination</li>
</ul>
<hr />
<h2><code>calli</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>calli</code> is an immediate call. In this situation, immediate means that the PC to jump to is taken from <code>dc0</code>. This also increments <code>dc0</code> and puts the incremented copy of <code>dc0</code> onto the <a href="architecture/cstack.html">cstack</a>, along with the other state elements preserved in a call.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is pushed
<ul>
<li>DCs are preserved</li>
<li>PC is preserved</li>
<li>Whether an interrupt is being serviced or not is preserved</li>
</ul>
</li>
</ul>
<h4>Examples</h4>
<pre><code>subr calli
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<hr />
<h2><code>jmpi</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jmpi</code> jumps to an immediate value stored at <code>dc0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value</li>
<li><code>dc0</code> is incremented</li>
</ul>
<hr />
<h2><code>jc</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jc</code> jumps to an immediate value stored at <code>dc0</code> if the <code>c</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>c</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jnc</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jnc</code> jumps to an immediate value stored at <code>dc0</code> if the <code>c</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>c</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jo</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jo</code> jumps to an immediate value stored at <code>dc0</code> if the <code>o</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>o</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jno</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jno</code> jumps to an immediate value stored at <code>dc0</code> if the <code>o</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>o</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>ji</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ji</code> jumps to an immediate value stored at <code>dc0</code> if the <code>iflag</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process. To indicate that the interrupt has been seen, <code>iflag</code> is set to <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>iflag</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
<li><code>iflag</code> is set to <code>0</code></li>
</ul>
<hr />
<h2><code>jni</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jni</code> jumps to an immediate value stored at <code>dc0</code> if the <code>iflag</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process. To indicate that the interrupt has been seen, <code>iflag</code> is set to <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>iflag</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
<li><code>iflag</code> is set to <code>0</code></li>
</ul>
<hr />
<h2><code>call</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>call</code> calls a subroutine. The address <code>a</code> is the destination the PC is set to. This pushes the <a href="architecture/cstack.html">cstack</a>, storing all the state elements preserved in a call.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is pushed
<ul>
<li>DCs are preserved</li>
<li>PC is preserved</li>
<li>Whether an interrupt is being serviced or not is preserved</li>
</ul>
</li>
</ul>
<h4>Examples</h4>
<pre><code>subr read0 call
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<hr />
<h2><code>jmp</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>jmp</code> jumps to the address <code>a</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to <code>a</code></li>
</ul>
<hr />
<h2><code>jeq</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>jeq</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> and <code>b</code> are equal. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a == b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jne</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>jne</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> and <code>b</code> are not equal. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a != b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>les</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>les</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than <code>b</code> in a signed comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt; b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>leq</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>leq</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in a signed comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lesu</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lesu</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt; b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lequ</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lequ</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lequ</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lequ</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>loop</code></h2>
<p><code>n e --</code></p>
<h4>Description</h4>
<p><code>loop</code> pushes a new loop into onto the <a href="architecture/lstack.html">lstack</a>. <code>n</code> represents the number of iterations of the loop, while <code>e</code> represents the end address of the loop. The loop index (<code>i0</code>) begins at <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/lstack.html">lstack</a> is pushed</li>
</ul>
<hr />
<h2><code>loopi</code></h2>
<p><code>n --</code></p>
<h4>Description</h4>
<p><code>loopi</code> pushes a new loop into onto the <a href="architecture/lstack.html">lstack</a>. <code>n</code> represents the number of iterations of the loop. The end address is taken from <code>dc0</code> and <code>dc0</code> is incremented. The loop index (<code>i0</code>) begins at <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/lstack.html">lstack</a> is pushed</li>
<li><code>dc0</code> is incremented</li>
</ul>
<h1>UARC Instructions</h1>
<h2><code>ien</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ien</code> enables interrupts in the <a href="architecture/ifile.html">ifile</a> for buses which are presently selected.</p>
<h4>Side Effects</h4>
<ul>
<li>All selected buses now have interrupts enabled.</li>
</ul>
<hr />
<h2><code>idi</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>idi</code> disables all interrupts currently enabled.</p>
<h4>Side Effects</h4>
<ul>
<li>All buses now have interrupts disabled.</li>
</ul>
<hr />
<h2><code>recv</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>recv</code> accepts any interrupt synchronously without an interrupt handler from any selected bus. The bus ID and the interrupt value are added to the <a href="architecture/conveyor.html">conveyor</a> in that order.</p>
<h4>Side Effects</h4>
<ul>
<li><code>cv &lt;- bus, v</code></li>
<li>Synchronizes execution with the next interrupt</li>
</ul>
<hr />
<h2><code>in</code></h2>
<p><code>a -- b</code></p>
<h4>Description</h4>
<p><code>in</code> receives a stream from any selected UARC bus. <code>a</code> is the address at which those words are to be streamed to. <code>b</code> is the bus ID of the particular bus that streamed these values.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the completion of the stream operation</li>
</ul>
<hr />
<h2><code>kill</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>kill</code> causes every single core connected to every selected bus and every single one of their children to stop before the instruction completes. This instruction takes <code>2 * n</code> cycles, where <code>n</code> is the depth of the longest chain of incepted cores. This will not succeed unless the core has <a href="uarc.html">permission</a> over the target cores. If the target does not have the proper <a href="uarc.html">permission</a>, it will report success without doing anything.</p>
<h4>Side Effects</h4>
<ul>
<li>All selected cores for which this core has permission will be stopped before this instruction finishes.</li>
</ul>
<hr />
<h2><code>wait</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>wait</code> allows the code to synchronously handle interrupts by waiting the core until the next interrupt. If an interrupt had already been received, the <code>iflag</code> will already be <code>1</code>. After this instruction executes, the <code>iflag</code> is set to <code>0</code> to indicate that no interrupts have executed that the kernel has not witnessed.</p>
<h4>Side Effects</h4>
<ul>
<li>One interrupt will have been handled before this instruction completes.</li>
<li>The <code>iflag</code> is set to <code>0</code>.</li>
</ul>
<hr />
<h2><code>getp</code></h2>
<p><code>-- priv</code></p>
<h4>Description</h4>
<p><code>getp</code> places the <a href="uarc.html">privilege</a> of the current core on the stack. This value will range from <code>0</code> to <code>31</code>.</p>
<hr />
<h2><code>geta</code></h2>
<p><code>-- addr</code></p>
<h4>Description</h4>
<p><code>geta</code> places the <a href="uarc.html">address</a> of the current core on the stack. This value is 31 bits and will be placed in the least significant bits of the word.</p>
<h4>Notes</h4>
<ul>
<li>This instruction is not supported for a <code>WORD</code> that is less than 32 bits.</li>
</ul>
<hr />
<h2><code>seb</code></h2>
<p><code>b --</code></p>
<h4>Description</h4>
<p><code>seb</code> clears all buses from being selected and then sets a specific set of UARC buses to be selected. The upper <code>WORD/2</code> bits of <code>b</code> select randomly from a register file of select registers and the lower <code>WORD/2</code> bits are a mask that represent which bits to specifically assign to that select register.</p>
<h4>Side Effects</h4>
<ul>
<li>Specific UARC buses are now selected.</li>
</ul>
<hr />
<h2><code>slb</code></h2>
<p><code>b --</code></p>
<h4>Description</h4>
<p><code>seb</code> selects a specific set of UARC buses. The upper <code>WORD/2</code> bits of <code>b</code> select randomly from a register file of select registers and the lower <code>WORD/2</code> bits are a mask that represent which bits to specifically OR to that select register.</p>
<h4>Side Effects</h4>
<ul>
<li>Specific UARC buses are now added to the selection.</li>
</ul>
<hr />
<h2><code>iset</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>iset</code> sets the interrupt address of all selected UARC buses to <code>a</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>Any further interrupts on the selected UARC buses now call the routine at <code>a</code>.</li>
</ul>
<hr />
<h2><code>send</code></h2>
<p><code>v --</code></p>
<h4>Description</h4>
<p><code>send</code> sends a value to all selected UARC buses, and waits for all buses to accept the interrupt before continuing.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the acceptance of all interrupts sent.</li>
</ul>
<hr />
<h2><code>out</code></h2>
<p><code>n a --</code></p>
<h4>Description</h4>
<p><code>out</code> sends a stream to all selected UARC buses. <code>n</code> is the number of words able to be streamed out and <code>a</code> is the address at which those words are to be streamed from.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the completion of the stream operation.</li>
</ul>
<hr />
<h2><code>setp</code></h2>
<p><code>priv addr --</code></p>
<h4>Description</h4>
<p><code>setp</code> sets the <a href="uarc.html">permission</a> that is to be delegated to all incepted UARC cores. This value defaults to the same <a href="uarc.html">permission</a> that this core receives on inception. If the user attempts to set a <a href="uarc.html">permission</a> that the core doesn't have access to, this instruction will fail without warning. <code>priv</code> is the <strong>privilege</strong> from <code>0</code> to <code>31</code> assigned to incepted cores. <code>addr</code> is masked from the most significant values by <code>priv</code> bits to get the actual <strong>permission</strong>.</p>
<h4>Side Effects</h4>
<ul>
<li>All cores incepted after this instruction is executed will have this <a href="uarc.html">permission</a>.</li>
</ul>
<h1>UARC</h1>
<p>c0 is an official UARC ISA. The purpose of UARC is to make it trivial to combine cores that are specialized at performing their function, so as to alleviate the process of providing backwards compatibility and to provide better utilization. The purpose of c0 is somewhat counter to the purpose of UARC: to provide a general purpose architecture. c0 is designed to be an architecture with high instruction density and the capability to quickly respond to communications from other more-specialized cores. To this end its entire architecture is designed, down to the stack architecture that lets it immediately respond to interrupts.</p>
<p>c0, as a reference UARC implementation, must provide all standard UARC facilities. It must allow multicast interrupts and data streaming. It must also allow privilege delegation. Message passing is facilitated by sending words over the UARC bus or sending a stream over the UARC bus. Sending an interrupt to a core that is not running will cause the interrupt to wait for the core to accept the interrupt by starting. Sending a stream to a target that is currently not running will cause permissions to be delegated to that core and for the core to begin running the program streamed to it.</p>
<p>UARC permissions work in a hierarchy. If a core has incepted a core, it also has <strong>permission</strong> over all the cores incepted by that core. This means that any children cores can be stopped using the <code>kill</code> instruction. Such delegation allows an operating system to not only stop execution of processes, but also delegate permissions to those processes. To achieve this delegation capability, cores continuously share their <strong>permission</strong> with all targets. This is achieved by using a 5-bit bus with the <strong>privilege</strong> of the core, and a 31-bit bus displaying the <strong>address</strong> of the core. The only parts of the <strong>address</strong> that are relevant are those masked by the <strong>privilege</strong>, known as the <strong>permission</strong> of the core. A <strong>privilege</strong> of 0 indicates that a core has absolute <strong>permission</strong> over all cores, including all cores that are of the same privilege level. If the privilege level is 31, then all 31 <strong>address</strong> bits encode the <strong>permission</strong> of the core, which means such a core can only <code>kill</code> cores the exact same <strong>permission</strong>.</p>
<p>It is permitted for any core to attempt communications with any other core, regardless of either of their <strong>permission</strong>. However, some cores may have specific schemes to accept or reject communications based on a communicating core's delegated <strong>permission</strong>. For instance, a core might have a table of <strong>permission</strong> values that allow it to filter communications based on a core's parents. In c0, such elaborate systems must be implemented in software, but programmers should be aware that other systems might be capable of this.</p>
<p><code>kill</code> is a simple instruction, but it has a complicated result. All child cores of the core being killed must also be killed. To achieve this, the UARC bus has two lines. One line is for sending a kill signal and the other is for acknowledging completion. As soon as a core knows all children are stopped, it may assert the acknowledge line and stop on the next cycle. A core with no children may immediately assert the acknowledge line and stop as soon as possible, since it has already met the above condition. A side effect of this setup is that the kill signal will also take one cycle to propagate down through each core. It takes <code>2 * n</code> cycles to complete the <code>kill</code> instruction, depending on the depth of inception (<code>n</code>).</p>
<p>A corner case is that a core may try to send a kill signal to a core for which it doesn't have <strong>permission</strong> to kill. In this case, the core should acknowledge immediately without doing anything to prevent deadlock. Also, any core which is already killed should continue to assert the acknowledge line to prevent deadlock in the case that the core is not even running. This also allows cores to know when another core is no longer running, though c0 is not capable of detecting this.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
