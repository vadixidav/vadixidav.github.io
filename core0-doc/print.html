<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>UARC core0</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="overview.html"><strong>1.</strong> Overview</a></li><li><a href="architecture.html"><strong>2.</strong> Architecture</a></li><li><ul class="section"><li><a href="architecture/dstack.html"><strong>2.1.</strong> dstack</a></li><li><a href="architecture/cstack.html"><strong>2.2.</strong> cstack</a></li><li><a href="architecture/lstack.html"><strong>2.3.</strong> lstack</a></li><li><a href="architecture/tstack.html"><strong>2.4.</strong> tstack</a></li><li><a href="architecture/ifile.html"><strong>2.5.</strong> ifile</a></li><li><a href="architecture/conveyor.html"><strong>2.6.</strong> conveyor</a></li></ul></li><li><a href="instruction_reference.html"><strong>3.</strong> Instruction Reference</a></li><li><ul class="section"><li><a href="instruction_reference/arithmetic.html"><strong>3.1.</strong> Arithmetic</a></li><li><a href="instruction_reference/stack_manipulation.html"><strong>3.2.</strong> Stack Manipulation</a></li><li><a href="instruction_reference/memory.html"><strong>3.3.</strong> Memory</a></li><li><a href="instruction_reference/uarc.html"><strong>3.4.</strong> UARC</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">UARC core0</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Overview</h1>
<p>UARC core0 (c0) is the primary general purpose ISA for the UARC standardized core collection. Although it is an ISA, a reference implementation is provided via emulator and VHDL.</p>
<p>This architecture is targeted towards small size and efficiency in shuffling data around across the UARC bus. No floating point instructions are included since it is expected that such algorithms will not run on core0, but will instead be offloaded to another UARC compatible core with floating point support. Due to the nature of UARC, it is possible to implement floating point operations using a coprocessor that connects over the UARC bus if desired.</p>
<p>It is important to note that although this core can be used for an OS that spreads cross multiple UARC cores, it is not intended to be the target of user space applications, except where those applications need to shuffle data around between UARC cores or only require integer arithmetic. c0 demonstrates the UARC principle while simultaneously acting as a mediator of data between UARC cores.</p>
<p>c0's ISA is designed to use whatever word size is required, but it is intended to be used as a 32-bit architecture.</p>
<h1>Architecture</h1>
<h3>Status</h3>
<table><thead><tr><td>Symbol</td><td>Purpose</td></tr></thead>
<tr><td><code>c</code></td><td>Carry bit</td></tr>
<tr><td><code>o</code></td><td>Overflow bit</td></tr>
</table>
<p>c0 is a stack machine, meaning that all parameters are implicit and all destinations are implicit except for stack manipulation and memory access. For comparison, belt machines have an implicit destination and register machines (the most common) have explicit parameters and destination. This means that for many instructions, a stack machine's instruction is entirely composed of an opcode with no extra fields. For c0, half of all instructions only have an opcode field, but the other half (stack manipulation instructions) the instruction contains an opcode and location field. This means that c0 has <a href="instruction_reference.md">two instruction formats</a>.</p>
<p>Since no task switching is required in c0, it is not necessary to be concerned with the amount of state elements in the architecture, except where those elements require random access. Due to this, several stacks are present in the architecture, aside from the main stack on which most of the processor occurs: the <a href="architecture/dstack.md">dstack</a>. For instance, the architecture also has a dedicated <a href="architecture/cstack.md">call stack</a> so that parameters can be passed orderly to a called routine and be consumed without worrying about the return address. A zero-overhead loop unit is also present that allows automatic conditional branching back to the beginning of the inner-most loop. The stack that contains the various loop parameters is called the <a href="architecture/lstack.md">loop stack</a>.</p>
<p>Not all stacks present in c0 are Last-In First-Out (LIFO). The <a href="architecture/dstack.md">dstack</a> itself has dedicated copy and rotate instructions so that it is possible to copy or move things to the top of the stack. However, the <a href="architecture/dstack.md">dstack</a> copy instruction is intended to allow variables to be computed once and copied into place on the stack however many additional times they are required before the final value is consumed. Some values, such as temporaries used multiple times or in loops do not belong on the <a href="architecture/dstack.md">dstack</a> because they would interfere with the normal consumption and production of variables from routines, forcing them to be moved to memory or rotate other values over them to the top of the stack for usage repeatedly. Since both of these paradigms would be undesirable for performance and binary density, an alternate random-access register-file has been added known as the <a href="architecture/tstack.md">tstack</a>. This stack is a hybrid between a register file and a stack. Values can be pushed onto the top of the <a href="architecture/tstack.md">tstack</a>, but can also be randomly written and read from the top 32 values of the <a href="architecture/tstack.md">tstack</a>. An important feature of the <a href="architecture/tstack.md">tstack</a> is that when returning from a routine, the <a href="architecture/tstack.md">tstack</a> is automatically restored to its previous location before the call. Although this may make the <a href="architecture/tstack.md">tstack</a> sound like an enticing place to put parameters for a function, this is only true in some circumstances and in many others the <a href="architecture/tstack.md">tstack</a> could become polluted with extra values, and any instruction will ultimately produce its output on the <a href="architecture/dstack.md">dstack</a>, therefore an extra instruction will always be required to load the value onto the tstack anyways, regardless of if that instruction is in the caller, the callee, or another previous callee called from the caller. Due to the above reasons, parameters are always passed by convention via the <a href="architecture/dstack.md">dstack</a> and not the <a href="architecture/tstack.md">tstack</a>.</p>
<p>Finally, the <a href="architecture/ifile.md">ifile</a> is a register file containing the interrupt address, enable bit, and selection bit that corresponds to each UARC bus present on the core. Each of the interrupts can be individually enabled, disabled, and set. Using the selection mechanism, several addresses can be enabled, disabled, and set simultaneously to avoid wasting time setting up interrupts or sending/receiving messages to/from multiple targets.</p>
<h1>dstack</h1>
<h1>cstack</h1>
<h1>lstack</h1>
<h1>tstack</h1>
<h1>ifile</h1>
<h1>conveyor</h1>
<h1>Instruction Reference</h1>
<h3>c0 Instruction Formats</h3>
<table><thead><tr><td> Format </td><td> Layout </td></tr></thead>
<tr><td>I (Implicit)</td><td><code>OSSO OOOO</code></td></tr>
<tr><td>L (Loop)</td><td><code>OSSO OOLL</code></td></tr>
<tr><td>D (DC)</td><td><code>OSSO OOLL</code></td></tr>
<tr><td>C (Conveyor)</td><td><code>OSSO LLLL</code></td></tr>
<tr><td>R (Random Access)</td><td><code>OOOL LLLL</code></td></tr>
</table>
<ul>
<li><code>O</code> - Opcode bit</li>
<li><code>S</code> - Stack bit</li>
<li><code>L</code> - Location bit</li>
</ul>
<h3>Stack bits</h3>
<ul>
<li><code>00</code> - The stack is not popped or pushed.</li>
<li><code>01</code> - The stack is pushed once.</li>
<li><code>10</code> - The stack is popped once.</li>
<li><code>11</code> - The stack is popped twice.</li>
</ul>
<h3><code>I</code> - Implicit</h3>
<p>Implicit instructions have no explicit sources or destinations and all can be assumed from state information in the system. Such instructions include <code>add</code>, which takes parameters from the stack and places the result back on the stack.</p>
<h3><code>L</code> - Loop</h3>
<p>Loop instructions allow random read access to the loop index of the top 4 loops in the <a href="architecture/lstack.md">lstack</a>. This means that loops can be nested 4 times and are still able to retrieve the index in one instruction.</p>
<h3><code>D</code> - Data Counter</h3>
<p>Data Counter instructions are instructions that operate on a random one of the 4 available DCs. These can be set, read, written, randomly read, and randomly written.</p>
<h3><code>C</code> - Conveyor</h3>
<p>Conveyor instructions allow random read access to the 16 things on the <a href="architecture/conveyor.md">conveyor belt</a>. The things on the conveyor may actually not be present and when accessed, the completion of the operation corresponding to that spot on the conveyor will be synchronized. This allows several asynchronous operations to be linked to different locations on the conveyor and read randomly when they are needed.</p>
<h3><code>R</code> - Random</h3>
<p>For R type instructions, 32 locations can be randomly addressed. This means that 32 places can be copied and rotated on the <a href="architecture/dstack.md">dstack</a> and 32 places can be read and written on the <a href="architecture/tstack.md">tstack</a>.</p>
<h2>Key Words</h2>
<ul>
<li><code>WORD</code> - Data word width in use</li>
<li><code>c</code> - Carry bit</li>
<li><code>cv</code> - <a href="architecture/conveyor.md">Conveyor Belt</a></li>
<li><code>dc[0-3]</code> - Data Counters</li>
<li><code>pc</code> - Program Counter</li>
<li><code>i[0-3]</code> - Loop Indices</li>
<li><code>cv[0-F]</code> - <a href="architecture/conveyor.md">Conveyor Belt</a> Values</li>
<li><code>ts</code> - <a href="architecture/tstack.md">tstack</a></li>
<li><code>if</code> - <a href="architecture/ifile.md">ifile</a></li>
</ul>
<h2>Instruction Listing By Opcode</h2>
<table><thead><tr><td>Op</td><td>Instruction</td><td>dstack</td><td>Side Effects</td></tr></thead>
<tr><td><code>00</code> - <code>03</code></td><td>rread#</td><td><code>a -- mem[dc# + a]</code></td></tr>
<tr></tr>
<tr><td><code>04</code></td><td>inc</td><td><code>a -- (a + 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>05</code></td><td>dec</td><td><code>a -- (a - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>06</code></td><td>flush</td><td><code>--</code></td><td>Synchronizes cache flush</td></tr>
<tr><td><code>07</code></td><td>reads</td><td><code>a -- mem[a]</code></td><td>Synchronous read</td></tr>
<tr><td><code>08</code></td><td>ret</td><td><code>--</code></td><td>Pops <a href="architecture/cstack.md">cstack</a></td></tr>
<tr><td><code>09</code></td><td>ien</td><td><code>--</code></td><td>Enables selected interrupts</td></tr>
<tr><td><code>0A</code></td><td>idi</td><td><code>--</code></td><td>Disables selected interrupts</td></tr>
<tr><td><code>0B</code></td><td>tcopy</td><td><code>v -- v</code></td><td>Pushes a copy of v to <a href="architecture/tstack.md">tstack</a></td></tr>
<tr><td><code>0C</code></td><td>recv</td><td><code>--</code></td><td>Interrupt sync; <code>cv &lt;- bus, v</code></td></tr>
<tr><td><code>16</code></td><td>calli</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code>; push <a href="architecture/cstack.md">cstack</a></td></tr>
<tr><td><code>17</code></td><td>jmpi</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>20</code> - <code>2F</code></td><td>cv#</td><td><code>-- cv#</code></td><td>cv# synchronizes</td></tr>
<tr><td><code>30</code> - <code>33</code></td><td>read#</td><td><code>-- mem[dc#]</code></td><td>dc# advances</td></tr>
<tr><td><code>34</code> - <code>37</code></td><td>i#</td><td><code>-- i#</code></td><td> </td></tr>
<tr><td><code>38</code></td><td>p0</td><td><code>-- 0</code></td><td> </td></tr>
<tr><td><code>39</code></td><td>dup</td><td><code>a -- a a</code></td><td> </td></tr>
<tr><td><code>40</code> - <code>43</code></td><td>write#</td><td><code>v --</code></td><td><code>mem[dc#] = v</code>; dc# advances</td></tr>
<tr><td><code>44</code> - <code>47</code></td><td>setf#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write post-inc</td></tr>
<tr><td><code>48</code> - <code>4B</code></td><td>setb#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write pre-dec</td></tr>
<tr><td><code>4C</code></td><td>add</td><td><code>a b -- (a + b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4D</code></td><td>addc</td><td><code>a b -- (a + b + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4E</code></td><td>sub</td><td><code>a b -- (a - b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4F</code></td><td>subc</td><td><code>a b -- (a - b + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>50</code></td><td>lsl</td><td><code>a b -- (a &lt;&lt; b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>51</code></td><td>lsr</td><td><code>a b -- (a &gt;&gt; b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>52</code></td><td>asr</td><td><code>a b -- (a &gt;&gt;&gt; b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>53</code></td><td>mul</td><td><code>a b -- (a * b)</code></td><td><code>cv &lt;- (a * b)[2*WORD-1:WORD]</code></td></tr>
<tr><td><code>54</code></td><td>mulu</td><td><code>a b -- (a * b)</code></td><td><code>cv &lt;- (a * b)[2*WORD-1:WORD]</code></td></tr>
<tr><td><code>55</code></td><td>reada</td><td><code>a --</code></td><td><code>cv &lt;- mem[a]</code></td></tr>
<tr><td><code>56</code></td><td>call</td><td><code>a --</code></td><td><code>pc = a</code>; push <a href="architecture/cstack.md">cstack</a></td></tr>
<tr><td><code>57</code></td><td>jmp</td><td><code>a --</code></td><td><code>pc = a</code></td></tr>
<tr><td><code>58</code></td><td>tpush</td><td><code>a --</code></td><td><code>t</code></td></tr>
<tr><td><code>59</code></td><td>seb</td><td><code>b --</code></td><td><code>if[b[WORD-1:WORD/2]] = b[WORD/2-1:0]</code></td></tr>
<tr><td><code>5A</code></td><td>slb</td><td><code>b --</code></td><td><code>b[WORD/2-1:0]</code> to <code>if[b[WORD-1:WORD/2]]</code></td></tr>
<tr><td><code>5B</code></td><td>iset</td><td><code>a --</code></td><td>Set selected interrupt addresses</td></tr>
<tr><td><code>5C</code></td><td>send</td><td><code>v --</code></td><td>Send value to selected buses</td></tr>
<tr><td><code>5D</code></td><td>in</td><td><code>n a -- b</code></td><td>Stream n words in and push bus</td></tr>
<tr><td><code>60</code> - <code>63</code></td><td>rwrite#</td><td><code>v a --</code></td><td><code>mem[dc# + a] = v</code></td></tr>
<tr><td><code>64</code></td><td>write</td><td><code>v a --</code></td><td><code>mem[a] = v</code></td></tr>
<tr><td><code>65</code></td><td>jeq</td><td><code>a b --</code></td><td>if <code>a == b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>66</code></td><td>jne</td><td><code>a b --</code></td><td>if <code>a != b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>67</code></td><td>les</td><td><code>a b --</code></td><td>if <code>a &lt; b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>68</code></td><td>leq</td><td><code>a b --</code></td><td>if <code>a &lt;= b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>69</code></td><td>out</td><td><code>n a --</code></td><td>Stream n words to buses from a</td></tr>
<tr><td><code>69</code></td><td>div</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
<tr><td><code>6A</code></td><td>divu</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
</table>
<h1>Arithmetic Instructions</h1>
<h2><code>add</code></h2>
<p><code>a b -- (a + b)</code></p>
<h4>Description</h4>
<p><code>add</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them. The carry bit is set by this instruction, but is not consumed.</p>
<h4>Side Effects</h4>
<p><code>c = (a + b)[WORD]</code></p>
<h2><code>addc</code></h2>
<p><code>a b -- (a + b + c)</code></p>
<h4>Description</h4>
<p><code>addc</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them with <code>c</code>. Unlike <code>add</code>, <code>addc</code> consumes the carry, so ensure it is correctly set before issuing this instruction.</p>
<h4>Side Effects</h4>
<p><code>c = (a + b)[WORD]</code></p>
<h2><code>sub</code></h2>
<p><code>a b -- (a - b)</code></p>
<h4>Description</h4>
<p><code>sub</code> subtracts parameter <code>b</code> from <code>a</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs. The carry bit is not consumed by this instruction.</p>
<h2><code>subc</code></h2>
<p><code>a b -- (a - b + c)</code></p>
<h4>Description</h4>
<p><code>subc</code> subtracts parameter <code>b</code> from <code>a</code> and adds <code>c</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs.</p>
<h1>Stack Manipulation Instructions</h1>
<h1>Memory Instructions</h1>
<h1>UARC Instructions</h1>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
