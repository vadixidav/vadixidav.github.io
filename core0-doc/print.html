<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>UARC core0</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="overview.html"><strong>1.</strong> Overview</a></li><li><a href="architecture.html"><strong>2.</strong> Architecture</a></li><li><ul class="section"><li><a href="architecture/dstack.html"><strong>2.1.</strong> dstack</a></li><li><a href="architecture/cstack.html"><strong>2.2.</strong> cstack</a></li><li><a href="architecture/lstack.html"><strong>2.3.</strong> lstack</a></li><li><a href="architecture/tstack.html"><strong>2.4.</strong> tstack</a></li><li><a href="architecture/ifile.html"><strong>2.5.</strong> ifile</a></li><li><a href="architecture/conveyor.html"><strong>2.6.</strong> conveyor</a></li></ul></li><li><a href="instruction_reference.html"><strong>3.</strong> Instruction Reference</a></li><li><ul class="section"><li><a href="instruction_reference/arithmetic.html"><strong>3.1.</strong> Arithmetic</a></li><li><a href="instruction_reference/bit_manipulation.html"><strong>3.2.</strong> Bit Manipulation</a></li><li><a href="instruction_reference/stack_manipulation.html"><strong>3.3.</strong> Stack Manipulation</a></li><li><a href="instruction_reference/memory.html"><strong>3.4.</strong> Memory</a></li><li><a href="instruction_reference/control_flow.html"><strong>3.5.</strong> Control Flow</a></li><li><a href="instruction_reference/uarc.html"><strong>3.6.</strong> UARC</a></li></ul></li><li><a href="uarc.html"><strong>4.</strong> UARC</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">UARC core0</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Overview</h1>
<p>UARC core0 (c0) is the primary general purpose ISA for the UARC standardized core collection. Although it is an ISA, a reference implementation is provided via emulator and SystemVerilog.</p>
<p>This architecture is targeted towards small size and efficiency in shuffling data around across the UARC bus. No floating point instructions are included since it is expected that such algorithms will not run on core0, but will instead be offloaded to another UARC compatible core with floating point support. Due to the nature of UARC, it is possible to implement floating point operations using a coprocessor that connects over the UARC bus if desired.</p>
<p>It is important to note that although this core can be used for an OS that spreads cross multiple UARC cores, it is not intended to be the target of user space applications, except where those applications need to shuffle data around between UARC cores or only require integer arithmetic. c0 demonstrates the UARC principle while simultaneously acting as a mediator of data between UARC cores.</p>
<p>c0's ISA is designed to use whatever word size is required, but it is intended to be used as a 32-bit architecture.</p>
<h1>Architecture</h1>
<h3>Status</h3>
<table><thead><tr><td>Symbol</td><td>Purpose</td></tr></thead>
<tr><td><code>c</code></td><td>Carry bit</td></tr>
<tr><td><code>o</code></td><td>Overflow bit</td></tr>
</table>
<p>c0 is a stack machine, meaning that all parameters are implicit and all destinations are implicit except for stack manipulation and memory access. For comparison, belt machines have an implicit destination and register machines (the most common) have explicit parameters and destination. This means that for many instructions, a stack machine's instruction is entirely composed of an opcode with no extra fields. For c0, half of all instructions only have an opcode field, but the other half (stack manipulation instructions) the instruction contains an opcode and location field. This means that c0 has <a href="instruction_reference.html">two instruction formats</a>.</p>
<p>Since no task switching is required in c0, it is not necessary to be concerned with the amount of state elements in the architecture, except where those elements require random access. Due to this, several stacks are present in the architecture, aside from the main stack on which most of the processor occurs: the <a href="architecture/dstack.html">dstack</a>. For instance, the architecture also has a dedicated <a href="architecture/cstack.html">call stack</a> so that parameters can be passed orderly to a called routine and be consumed without worrying about the return address. A zero-overhead loop unit is also present that allows automatic conditional branching back to the beginning of the inner-most loop. The stack that contains the various loop parameters is called the <a href="architecture/lstack.html">loop stack</a>.</p>
<p>Not all stacks present in c0 are Last-In First-Out (LIFO). The <a href="architecture/dstack.html">dstack</a> itself has dedicated copy and rotate instructions so that it is possible to copy or move things to the top of the stack. However, the <a href="architecture/dstack.html">dstack</a> copy instruction is intended to allow variables to be computed once and copied into place on the stack however many additional times they are required before the final value is consumed. Some values, such as temporaries used multiple times or in loops do not belong on the <a href="architecture/dstack.html">dstack</a> because they would interfere with the normal consumption and production of variables from routines, forcing them to be moved to memory or rotate other values over them to the top of the stack for usage repeatedly. Since both of these paradigms would be undesirable for performance and binary density, an alternate random-access register-file has been added known as the <a href="architecture/tstack.html">tstack</a>. This stack is a hybrid between a register file and a stack. Values can be pushed onto the top of the <a href="architecture/tstack.html">tstack</a>, but can also be randomly written and read from the top 32 values of the <a href="architecture/tstack.html">tstack</a>. An important feature of the <a href="architecture/tstack.html">tstack</a> is that when returning from a routine, the <a href="architecture/tstack.html">tstack</a> is automatically restored to its previous location before the call. Although this may make the <a href="architecture/tstack.html">tstack</a> sound like an enticing place to put parameters for a function, this is only true in some circumstances and in many others the <a href="architecture/tstack.html">tstack</a> could become polluted with extra values, and any instruction will ultimately produce its output on the <a href="architecture/dstack.html">dstack</a>, therefore an extra instruction will always be required to load the value onto the tstack anyways, regardless of if that instruction is in the caller, the callee, or another previous callee called from the caller. Due to the above reasons, parameters are always passed by convention via the <a href="architecture/dstack.html">dstack</a> and not the <a href="architecture/tstack.html">tstack</a>.</p>
<p>Finally, the <a href="architecture/ifile.html">ifile</a> is a register file containing the interrupt address, enable bit, and selection bit that corresponds to each UARC bus present on the core. Each of the interrupts can be individually enabled, disabled, and set. Using the selection mechanism, several addresses can be enabled, disabled, and set simultaneously to avoid wasting time setting up interrupts or sending/receiving messages to/from multiple targets.</p>
<h1>dstack</h1>
<h1>cstack</h1>
<h1>lstack</h1>
<h1>tstack</h1>
<h1>ifile</h1>
<h1>conveyor</h1>
<h1>Instruction Reference</h1>
<h3>c0 Instruction Formats</h3>
<table><thead><tr><td> Format </td><td> Layout </td></tr></thead>
<tr><td>I (Implicit)</td><td><code>OSSO OOOO</code></td></tr>
<tr><td>L (Loop)</td><td><code>OSSO OOLL</code></td></tr>
<tr><td>D (DC)</td><td><code>OSSO OOLL</code></td></tr>
<tr><td>C (Conveyor)</td><td><code>OSSO LLLL</code></td></tr>
<tr><td>R (Random Access)</td><td><code>OOOL LLLL</code></td></tr>
</table>
<ul>
<li><code>O</code> - Opcode bit</li>
<li><code>S</code> - Stack bit</li>
<li><code>L</code> - Location bit</li>
</ul>
<h3>Stack bits</h3>
<ul>
<li><code>00</code> - The stack is not popped or pushed.</li>
<li><code>01</code> - The stack is pushed once.</li>
<li><code>10</code> - The stack is popped once.</li>
<li><code>11</code> - The stack is popped twice.</li>
</ul>
<h3><code>I</code> - Implicit</h3>
<p>Implicit instructions have no explicit sources or destinations and all can be assumed from state information in the system. Such instructions include <code>add</code>, which takes parameters from the stack and places the result back on the stack.</p>
<h3><code>L</code> - Loop</h3>
<p>Loop instructions allow random read access to the loop index of the top 4 loops in the <a href="architecture/lstack.html">lstack</a>. This means that loops can be nested 4 times and are still able to retrieve the index in one instruction.</p>
<h3><code>D</code> - Data Counter</h3>
<p>Data Counter instructions are instructions that operate on a random one of the 4 available DCs. These can be set, get, read, written, randomly read, and randomly written.</p>
<h3><code>C</code> - Conveyor</h3>
<p>Conveyor instructions allow random read access to the 16 things on the <a href="architecture/conveyor.html">conveyor belt</a>. The things on the conveyor may actually not be present and when accessed, the completion of the operation corresponding to that spot on the conveyor will be synchronized. This allows several asynchronous operations to be linked to different locations on the conveyor and read randomly when they are needed.</p>
<h3><code>R</code> - Random</h3>
<p>For R type instructions, 32 locations can be randomly addressed. This means that 32 places can be copied and rotated on the <a href="architecture/dstack.html">dstack</a> and 32 places can be read and written on the <a href="architecture/tstack.html">tstack</a>.</p>
<h2>Key</h2>
<ul>
<li><code>WORD</code> - Data word width in use</li>
<li><code>c</code> - Carry bit</li>
<li><code>cv</code> - <a href="architecture/conveyor.html">Conveyor Belt</a></li>
<li><code>dc[0-3]</code> - Data Counters</li>
<li><code>pc</code> - Program Counter</li>
<li><code>i[0-3]</code> - Loop Indices</li>
<li><code>cv[0-F]</code> - <a href="architecture/conveyor.html">Conveyor Belt</a> Values</li>
<li><code>ts</code> - <a href="architecture/tstack.html">tstack</a></li>
<li><code>ls</code> - <a href="architecture/lstack.html">lstack</a></li>
<li><code>if</code> - <a href="architecture/ifile.html">ifile</a></li>
<li><code>n..</code> - <code>n</code> anonymous words on the stack</li>
</ul>
<h2>Instruction Listing By Opcode</h2>
<table><thead><tr><td>Op</td><td>Instruction</td><td>dstack</td><td>Side Effects</td></tr></thead>
<tr><td><code>00</code> - <code>03</code></td><td>rread#</td><td><code>a -- mem[dc# + a]</code></td></tr>
<tr></tr>
<tr><td><code>04</code></td><td>inc</td><td><code>a -- (a + 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>05</code></td><td>dec</td><td><code>a -- (a - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>06</code></td><td>carry</td><td><code>v -- (v + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>07</code></td><td>borrow</td><td><code>v -- (v + c - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>08</code></td><td>inv</td><td><code>v -- ~v</code></td><td> </td></tr>
<tr><td><code>09</code></td><td>flush</td><td><code>--</code></td><td>Synchronizes cache flush</td></tr>
<tr><td><code>0A</code></td><td>reads</td><td><code>a -- mem[a]</code></td><td>Synchronous read</td></tr>
<tr><td><code>0B</code></td><td>ret</td><td><code>--</code></td><td>Pops <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>0C</code></td><td>ien</td><td><code>--</code></td><td>Enables selected interrupts</td></tr>
<tr><td><code>0D</code></td><td>idi</td><td><code>--</code></td><td>Disables all interrupts</td></tr>
<tr><td><code>0E</code></td><td>tcopy</td><td><code>v -- v</code></td><td>Pushes a copy of v to <a href="architecture/tstack.html">tstack</a></td></tr>
<tr><td><code>0F</code></td><td>recv</td><td><code>--</code></td><td>Interrupt sync; <code>cv &lt;- bus, v</code></td></tr>
<tr><td><code>10</code></td><td>in</td><td><code>a -- b</code></td><td>Stream in to <code>a</code></td></tr>
<tr><td><code>11</code></td><td>kill</td><td><code>--</code></td><td>Kill all selected cores</td></tr>
<tr><td><code>16</code></td><td>calli</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code>; push <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>17</code></td><td>jmpi</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>18</code></td><td>jc</td><td><code>--</code></td><td>if <code>c</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>19</code></td><td>jnc</td><td><code>--</code></td><td>if <code>~c</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1A</code></td><td>jo</td><td><code>--</code></td><td>if <code>o</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1B</code></td><td>jno</td><td><code>--</code></td><td>if <code>~o</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>20</code> - <code>2F</code></td><td>cv#</td><td><code>-- cv#</code></td><td>cv# synchronizes</td></tr>
<tr><td><code>30</code> - <code>33</code></td><td>read#</td><td><code>-- mem[dc#]</code></td><td>dc# advances</td></tr>
<tr><td><code>34</code> - <code>37</code></td><td>get#</td><td><code>-- dc#</code></td><td> </td></tr>
<tr><td><code>38</code> - <code>3B</code></td><td>i#</td><td><code>-- i#</code></td><td> </td></tr>
<tr><td><code>3C</code></td><td>p0</td><td><code>-- 0</code></td><td> </td></tr>
<tr><td><code>3D</code></td><td>dup</td><td><code>v -- v v</code></td><td> </td></tr>
<tr><td><code>3E</code></td><td>getp</td><td><code>-- priv</code></td><td>Get UARC privilege</td></tr>
<tr><td><code>3F</code></td><td>geta</td><td><code>-- addr</code></td><td>Get UARC address</td></tr>
<tr><td><code>40</code> - <code>43</code></td><td>write#</td><td><code>v --</code></td><td><code>mem[dc#] = v</code>; dc# advances</td></tr>
<tr><td><code>44</code> - <code>47</code></td><td>setf#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write post-inc</td></tr>
<tr><td><code>48</code> - <code>4B</code></td><td>setb#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write pre-dec</td></tr>
<tr><td><code>4C</code></td><td>add</td><td><code>a b -- (a + b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4D</code></td><td>addc</td><td><code>a b -- (a + b + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4E</code></td><td>sub</td><td><code>a b -- (a - b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4F</code></td><td>subc</td><td><code>a b -- (a - b + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>50</code></td><td>lsl</td><td><code>a b -- (a &lt;&lt; b)</code></td><td><code>o</code></td></tr>
<tr><td><code>51</code></td><td>lsr</td><td><code>a b -- (a &gt;&gt; b)</code></td><td><code>o</code></td></tr>
<tr><td><code>52</code></td><td>csl</td><td><code>a b -- ((a &lt;&lt; b) or (a &gt;&gt; (b - WORD)))</code></td><td> </td></tr>
<tr><td><code>53</code></td><td>csr</td><td><code>a b -- ((a &gt;&gt; b) or (a &lt;&lt; (b - WORD)))</code></td><td> </td></tr>
<tr><td><code>54</code></td><td>asr</td><td><code>a b -- (a &gt;&gt;&gt; b)</code></td><td><code>o</code></td></tr>
<tr><td><code>55</code></td><td>and</td><td><code>a b -- (a &amp; b)</code></td><td> </td></tr>
<tr><td><code>56</code></td><td>or</td><td><code>a b -- (a or b)</code></td><td> </td></tr>
<tr><td><code>57</code></td><td>reada</td><td><code>a --</code></td><td><code>cv &lt;- mem[a]</code></td></tr>
<tr><td><code>58</code></td><td>call</td><td><code>a --</code></td><td><code>pc = a</code>; push <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>59</code></td><td>jmp</td><td><code>a --</code></td><td><code>pc = a</code></td></tr>
<tr><td><code>5A</code></td><td>tpush</td><td><code>a --</code></td><td><code>ts &lt;- a</code></td></tr>
<tr><td><code>5B</code></td><td>seb</td><td><code>b --</code></td><td><code>if[b[WORD-1:WORD/2]] = b[WORD/2-1:0]</code></td></tr>
<tr><td><code>5C</code></td><td>slb</td><td><code>b --</code></td><td><code>b[WORD/2-1:0]</code> to <code>if[b[WORD-1:WORD/2]]</code></td></tr>
<tr><td><code>5D</code></td><td>iset</td><td><code>a --</code></td><td>Set selected interrupt addresses</td></tr>
<tr><td><code>5E</code></td><td>send</td><td><code>v --</code></td><td>Send value to selected buses</td></tr>
<tr><td><code>5F</code></td><td>loopi</td><td><code>n --</code></td><td><code>ls &lt;- n, dc0, 0</code></td></tr>
<tr><td><code>60</code> - <code>63</code></td><td>rwrite#</td><td><code>v a --</code></td><td><code>mem[dc# + a] = v</code></td></tr>
<tr><td><code>64</code></td><td>write</td><td><code>v a --</code></td><td><code>mem[a] = v</code></td></tr>
<tr><td><code>65</code></td><td>jeq</td><td><code>a b --</code></td><td>if <code>a == b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>66</code></td><td>jne</td><td><code>a b --</code></td><td>if <code>a != b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>67</code></td><td>les</td><td><code>a b --</code></td><td>if <code>a &lt; b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>68</code></td><td>leq</td><td><code>a b --</code></td><td>if <code>a &lt;= b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>69</code></td><td>lesu</td><td><code>a b --</code></td><td>if <code>a &lt; b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>6A</code></td><td>lequ</td><td><code>a b --</code></td><td>if <code>a &lt;= b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>6B</code></td><td>out</td><td><code>n a --</code></td><td>Stream n words to buses from a</td></tr>
<tr><td><code>6C</code></td><td>mul</td><td><code>a b --</code></td><td><code>cv &lt;- low(a * b), high(a * b)</code></td></tr>
<tr><td><code>6D</code></td><td>mulu</td><td><code>a b --</code></td><td><code>cv &lt;- low(a * b), high(a * b)</code></td></tr>
<tr><td><code>6E</code></td><td>div</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
<tr><td><code>6F</code></td><td>divu</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
<tr><td><code>70</code></td><td>loop</td><td><code>n e --</code></td><td><code>ls &lt;- n, e, 0</code></td></tr>
<tr><td><code>71</code></td><td>setp</td><td><code>priv addr --</code></td><td>Sets UARC permission delegation</td></tr>
<tr><td><code>80</code> - <code>9F</code></td><td>rot#</td><td><code>v (# + 1).. -- (# + 1).. v</code></td><td> </td></tr>
<tr><td><code>A0</code> - <code>BF</code></td><td>copy#</td><td><code>v (# + 1).. -- v (# + 1).. v</code></td><td> </td></tr>
<tr><td><code>C0</code> - <code>DF</code></td><td>tread#</td><td><code>-- ts[#]</code></td><td>Address 0 is the top of ts</td></tr>
<tr><td><code>E0</code> - <code>FF</code></td><td>twrite#</td><td><code>v --</code></td><td><code>ts[#] = v</code></td></tr>
</table>
<h1>Arithmetic Instructions</h1>
<h2><code>inc</code></h2>
<p><code>a -- (a + 1)</code></p>
<h4>Description</h4>
<p><code>inc</code> increments the top of the <a href="architecture/dstack.html">dstack</a> by 1. The overflow and carry bits are set, but not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + 1 == 0)</code></li>
<li><code>o = (a + 1 == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>h7FFFFFFF inc
</code></pre>
<ul>
<li><code>( -- h80000000)</code></li>
<li><code>o</code> is set to 1 because a positive number became negative by wrapping</li>
<li><code>c</code> is set to 0</li>
</ul>
<hr />
<h2><code>dec</code></h2>
<p><code>a -- (a + 1)</code></p>
<h4>Description</h4>
<p><code>dec</code> decrements the top of the <a href="architecture/dstack.html">dstack</a> by 1. The overflow and carry bits are set, but not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a - 1 != ~0)</code></li>
<li><code>o = (a == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 dec
</code></pre>
<ul>
<li><code>( -- -1)</code></li>
<li><code>o</code> is set to 0 because no overflow occurred</li>
<li><code>c</code> is set to 1 because a borrow was incurred</li>
</ul>
<hr />
<h2><code>carry</code></h2>
<p><code>a -- (a + c)</code></p>
<h4>Description</h4>
<p><code>carry</code> is used when the carry bit needs to be accumulated to a more significant word after a less significant operation. It affects the <code>o</code> and <code>c</code> similarly to <code>inc</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = c == 1 &amp;&amp; (a + c == 0)</code></li>
<li><code>o = c == 1 &amp;&amp; (a == -1)</code></li>
</ul>
<h4>Examples</h4>
<pre><code>~0 inc
0 carry
</code></pre>
<ul>
<li><code>( -- 0 1)</code></li>
<li><code>c</code> is set to 0</li>
<li><code>o</code> is set to 0</li>
</ul>
<hr />
<h2><code>borrow</code></h2>
<p><code>a -- (a + c - 1)</code></p>
<h4>Description</h4>
<p><code>borrow</code> is used when a borrow must be applied to a more significant word after a less significant operation. It affects the <code>o</code> and <code>c</code> bits similarly to <code>dec</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = c == 1 || (a - 1 != ~0)</code></li>
<li><code>o = c == 1 || (a == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 dec
1 borrow
</code></pre>
<ul>
<li><code>( -- 0 0)</code></li>
<li><code>c</code> is set to 0</li>
<li><code>o</code> is set to 0</li>
</ul>
<hr />
<h2><code>add</code></h2>
<p><code>a b -- (a + b)</code></p>
<h4>Description</h4>
<p><code>add</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them. The carry bit is set by this instruction, but is not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + b)[WORD]</code></li>
<li><code>o = (a[WORD - 1] ^ b[WORD - 1]) ? 0 : a[WORD - 1] ^ (a + b)[WORD - 1]</code></li>
</ul>
<h4>Examples</h4>
<pre><code>2 3 add
</code></pre>
<ul>
<li><code>( -- 5)</code></li>
<li>Carry is set to 0</li>
</ul>
<hr />
<h2><code>addc</code></h2>
<p><code>a b -- (a + b + c)</code></p>
<h4>Description</h4>
<p><code>addc</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them with <code>c</code>. Unlike <code>add</code>, <code>addc</code> consumes the carry, so ensure it is correctly set before issuing this instruction.</p>
<h4>Side Effects</h4>
<p><code>c = (a + b)[WORD]</code></p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 h80000000 add
0 0 addc
</code></pre>
<ul>
<li><code>( -- 0 1)</code></li>
<li>Carry is set to 0</li>
</ul>
<hr />
<h2><code>sub</code></h2>
<p><code>a b -- (a - b)</code></p>
<h4>Description</h4>
<p><code>sub</code> subtracts parameter <code>b</code> from <code>a</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs. The carry bit is not consumed by this instruction.</p>
<h4>Side Effects</h4>
<p><code>c = (a - b)[WORD]</code></p>
<h4>Examples</h4>
<pre><code>2 3 sub
</code></pre>
<ul>
<li><code>( -- -1)</code></li>
<li>Carry is set to 0
<ul>
<li>Which indicates a borrow</li>
</ul>
</li>
</ul>
<hr />
<h2><code>subc</code></h2>
<p><code>a b -- (a - b + c)</code></p>
<h4>Description</h4>
<p><code>subc</code> subtracts parameter <code>b</code> from <code>a</code> and adds <code>c</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs.</p>
<h4>Side Effects</h4>
<p><code>c = (a - b)[WORD]</code></p>
<h4>Examples</h4>
<pre><code>2 3 sub
1 0 subc
</code></pre>
<ul>
<li><code>( -- -1 0)</code></li>
<li>Carry is set to 1 (indicating no borrow)</li>
</ul>
<hr />
<h2><code>asr</code></h2>
<p><code>a b -- (a &gt;&gt;&gt; b)</code></p>
<h4>Description</h4>
<p><code>asr</code> shifts <code>a</code> by <code>b</code> bits and sign extends the result. If <code>-1</code> is shifted right, it will continue to stay <code>-1</code>, but <code>o</code> will not be set. The <code>o</code> bit is set if any 1 bits are lost in a positive number or 0 bits lost in a negative number.</p>
<h4>Side Effects</h4>
<ul>
<li><code>o</code> is 1 if any significant bits were lost</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 1 asr
</code></pre>
<ul>
<li><code>( -- hC000000)</code></li>
<li><code>o</code> is set to <code>1</code> because <code>0</code> is a significant bit and is lost</li>
</ul>
<hr />
<h2><code>mul</code></h2>
<p><code>a b -- (a * b)</code></p>
<h4>Description</h4>
<p><code>mul</code> multiplies two signed numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The lower <code>WORD</code> and the higher <code>WORD</code> bits (both including a sign bit) are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The lowest <code>WORD</code> and highest <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
<li><code>o</code> is <code>1</code> if any significant bits are placed into the conveyor</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 2 mul cv1 cv0
</code></pre>
<ul>
<li><code>( -- h80000000 hFFFFFFFE)</code></li>
</ul>
<hr />
<h2><code>mulu</code></h2>
<p><code>a b -- (a * b)</code></p>
<h4>Description</h4>
<p><code>mulu</code> multiplies two unsigned numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The lower <code>WORD</code> and higher <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The lowest <code>WORD</code> and highest <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples</h4>
<pre><code>~0 2 mul cv1 cv0
</code></pre>
<ul>
<li><code>( -- ~0 1)</code></li>
</ul>
<hr />
<h2><code>div</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>div</code> divides two signed numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The higher/whole <code>WORD</code> and the lower/fractional <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>. Both the higher and the lower results are signed.</p>
<h4>Side Effects</h4>
<ul>
<li>The higher/whole <code>WORD</code> and lower/fractional <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 2 div cv1 cv0
</code></pre>
<ul>
<li><code>( -- hC0000000 hBFFFFFFF)</code></li>
</ul>
<hr />
<h2><code>divu</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>divu</code> divides two unsigned numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The higher/whole <code>WORD</code> and the lower/fractional <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The higher/whole <code>WORD</code> and lower/fractional <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>~0 2 divu cv1 cv0
</code></pre>
<ul>
<li><code>( -- h7FFFFFFF h80000000)</code></li>
</ul>
<h1>Bit Manipulation</h1>
<h2><code>inv</code></h2>
<p><code>v -- ~v</code></p>
<h4>Description</h4>
<p><code>inv</code> inverts the bits of v.</p>
<h4>Examples</h4>
<pre><code>~0 inv
</code></pre>
<ul>
<li><code>( -- 0)</code></li>
</ul>
<hr />
<h2><code>lsl</code></h2>
<p><code>a b -- (a &lt;&lt; b)</code></p>
<h4>Description</h4>
<p><code>lsl</code> performs a logical shift left. If any <code>1</code> bits are lost in the shift, the <code>o</code> bit is set to <code>1</code>, otherwise <code>0</code>. This operation zero-fills.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>hFFFFFFFF 1 lsl
</code></pre>
<ul>
<li><code>( -- hFFFFFFFE)</code></li>
<li><code>o</code> is set to <code>1</code></li>
</ul>
<hr />
<h2><code>lsr</code></h2>
<p><code>a b -- (a &gt;&gt; b)</code></p>
<h4>Description</h4>
<p><code>lsr</code> performs a logical shift right. If any <code>1</code> bits are lost in the shift, the <code>o</code> bit is set to <code>1</code>, otherwise <code>0</code>. This operation zero-fills.</p>
<h4>Examples</h4>
<pre><code>3 1 lsr
</code></pre>
<ul>
<li><code>( -- 1)</code></li>
<li><code>o</code> is set to <code>1</code></li>
</ul>
<hr />
<h2><code>csl</code></h2>
<p><code>a b -- ((a &lt;&lt; b) or (a &gt;&gt; (b - WORD)))</code></p>
<h4>Description</h4>
<p><code>csl</code> performs a circular shift left. Only the amount of bits needed are used for the shift amount. For example, with a 32-bit <code>WORD</code>, only the least significant <code>5</code> bits are masked out of <code>b</code>.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>hC0000000 1 csl
</code></pre>
<ul>
<li><code>( -- h80000001)</code></li>
</ul>
<hr />
<h2><code>csr</code></h2>
<p><code>a b -- ((a &gt;&gt; b) or (a &lt;&lt; (b - WORD)))</code></p>
<h4>Description</h4>
<p><code>csr</code> performs a circular shift right. Only the amount of bits needed are used for the shift amount. For example, with a 32-bit <code>WORD</code>, only the least significant <code>5</code> bits are masked out of <code>b</code>.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>3 1 csr
</code></pre>
<ul>
<li><code>( -- h80000001)</code></li>
</ul>
<hr />
<h2><code>and</code></h2>
<p><code>a b -- (a &amp; b)</code></p>
<h4>Description</h4>
<p><code>and</code> finds the binary AND of <code>a</code> and <code>b</code>.</p>
<h4>Examples</h4>
<pre><code>5 4 and
</code></pre>
<ul>
<li><code>( -- 4)</code></li>
</ul>
<hr />
<h2><code>or</code></h2>
<p><code>a b -- (a or b)</code></p>
<h4>Description</h4>
<p><code>or</code> finds the binary OR of <code>a</code> and <code>b</code>.</p>
<h4>Examples</h4>
<pre><code>5 2 or
</code></pre>
<ul>
<li><code>( -- 7)</code></li>
</ul>
<h1>Stack Manipulation Instructions</h1>
<h2><code>tcopy</code></h2>
<p><code>v -- v</code></p>
<h4>Description</h4>
<p><code>tcopy</code> pushes a copy of <code>v</code> onto the <a href="architecture/tstack.html">tstack</a>.</p>
<h4>Side Effects</h4>
<ul>
<li><code>v</code> is pushed onto the <code>tstack</code>, moving everything down relative to the top</li>
</ul>
<h4>Examples</h4>
<pre><code>1 tcopy tread0
</code></pre>
<ul>
<li><code>( -- 1)</code></li>
</ul>
<hr />
<h2><code>p0</code></h2>
<p><code>-- 0</code></p>
<h4>Description</h4>
<p><code>p0</code> pushes a <code>0</code> onto the top of the stack. This doesn't theoretically need to exist, but it makes it practically easy for the processor to add a <code>0</code> to the stack on inception to receive the data stream from the inceptor. It also has other uses, such as initializing an accumulator value and comparisons with <code>0</code>.</p>
<hr />
<h2><code>dup</code></h2>
<p><code>v -- v v</code></p>
<h4>Description</h4>
<p><code>dup</code> fills a void where <code>copy#</code> cannot, which is copying the top of the stack. Since <code>copy#</code> and <code>rot#</code> address starting from the element directly under the top of stack, this instruction is dedicated to allow copying the top of the stack.</p>
<hr />
<h2><code>tpush</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>tpush</code> removes <code>a</code> from the stack and places it on the <a href="architecture/tstack.html">tstack</a>. This should be used when a loop is about to execute and requires a temporary value to be accessed repeatedly, but the value is not otherwise consumed from the stack.</p>
<hr />
<h2><code>rot#</code></h2>
<p><code>v (# + 1).. -- (# + 1).. v</code></p>
<h4>Description</h4>
<p><code>rot#</code> rotates a value <code>1</code> to <code>32</code> elements deep in the stack to the top of the stack. The value is removed from that location and elements under that value are not shifted in the stack.</p>
<h4>Examples</h4>
<pre><code>1 2 3 rot1
</code></pre>
<ul>
<li><code>( -- 2 3 1)</code></li>
</ul>
<hr />
<h2><code>copy#</code></h2>
<p><code>v (# + 1).. -- v (# + 1).. v</code></p>
<h4>Description</h4>
<p><code>copy#</code> copies a value <code>1</code> to <code>32</code> elements deep in the stack to the top of the stack. This pushes all elements down on the stack.</p>
<h4>Examples</h4>
<pre><code>1 2 3 copy1
</code></pre>
<ul>
<li><code>( -- 1 2 3 1)</code></li>
</ul>
<h1>Memory Instructions</h1>
<h2><code>rread#</code></h2>
<p><code>a -- mem[dc# + a]</code></p>
<h4>Description</h4>
<p><code>rread#</code> performs a random read starting from <code>dc#</code> and indexing by <code>a</code>. The result is returned synchronously to the stack because it is assumed that this value is held in the cache, since memory at a dc is generally cached.</p>
<hr />
<h2><code>flush</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>flush</code> forces all dirty cache to be written to memory before this instruction completes execution.</p>
<h4>Side Effects</h4>
<ul>
<li>Dirty cache is flushed to main memory</li>
</ul>
<h4>Examples</h4>
<pre><code>write flush send
</code></pre>
<ul>
<li><code>(send_val write_val address -- )</code></li>
<li>On a ccNUMA architecture, the other core can now access the value <code>write_val</code> at <code>address</code></li>
<li>The other core is interrupted only after the value has been flushed to memory</li>
</ul>
<hr />
<h2><code>reads</code></h2>
<p><code>a -- mem[a]</code></p>
<h4>Description</h4>
<p><code>reads</code> performs a synchronous read, meaning that this operation does not complete until the value is on the stack. <code>a</code> is an absolute address.</p>
<hr />
<h2><code>read#</code></h2>
<p><code>-- mem[dc#]</code></p>
<h4>Description</h4>
<p><code>read#</code> performs a read directly at <code>dc#</code>. Doing this increments <code>dc#</code> after the read.</p>
<hr />
<h2><code>get#</code></h2>
<p><code>-- dc#</code></p>
<h4>Description</h4>
<p><code>get#</code> places the address dc# is currently pointing to onto the stack. This allows the programmer to manipulate the dc for allocating memory on a stack or advancing the dc between elements in a vector for use with <code>rread#</code>.</p>
<hr />
<h2><code>write#</code></h2>
<p><code>v --</code></p>
<h4>Description</h4>
<p><code>write#</code> performs a write directly at <code>dc#</code>. Doing this advances <code>dc#</code> depending on how it was set. If it was set with <code>setf</code>, then <code>dc#</code> will write and then increment. If it was set with <code>setb</code>, then <code>dc#</code> will decrement and then write. Due to this behavior, using setb allows a dc to be set up as a pushdown stack.</p>
<hr />
<h2><code>setf#</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>setf#</code> sets <code>dc#</code> to <code>a</code>. It also sets <code>dc#</code> to be in post-increment write mode.</p>
<hr />
<h2><code>setb#</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>setf#</code> sets <code>dc#</code> to <code>a</code>. It also sets <code>dc#</code> to be in pre-decrement write mode.</p>
<hr />
<h2><code>reada</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>reada</code> performs an asynchronous read. This means that the value read will not necessarily complete before the next instruction and the result is not put on the stack. Instead, the value is promised in a slot on the <a href="architecture/conveyor.html">conveyor</a>. When this slot is read from, the read is synchronized and the result is placed on the stack.</p>
<h4>Side Effects</h4>
<ul>
<li><code>cv &lt;- mem[a]</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 reada
# Do other stuff here
cv0
</code></pre>
<ul>
<li><code>( -- mem[0])</code></li>
<li>Between <code>reada</code> and <code>cv0</code>, any operations happen while the read is occurring.</li>
</ul>
<hr />
<h2><code>rwrite#</code></h2>
<p><code>v a --</code></p>
<h4>Description</h4>
<p><code>rwrite#</code> performs a random write relative to <code>dc#</code>. This means that <code>mem[dc# + a] = v</code>. This may be cached.</p>
<h4>Side Effects</h4>
<ul>
<li><code>mem[dc# + a] = v</code></li>
</ul>
<hr />
<h2><code>write</code></h2>
<p><code>v a --</code></p>
<h4>Description</h4>
<p><code>write</code> performs a random write. This means that <code>mem[a] = v</code>. This may be cached.</p>
<h4>Side Effects</h4>
<ul>
<li><code>mem[a] = v</code></li>
</ul>
<h1>Control Flow</h1>
<h2><code>ret</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ret</code> returns from a subroutine call. It pops the <a href="architecture/cstack.html">cstack</a>, moving the PC, DCs, and <a href="architecture/tstack.html">tstack</a> back to the position it was at in the caller to continue execution. This instruction returns from interrupts as well as normal subroutines, since an interrupt is a simulated subroutine call. Using <code>ret</code> in an interrupt also allows more interrupts to be serviced unless they are explicitly disabled in the interrupt.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is popped
<ul>
<li>DCs are returned to their previous values</li>
<li>PC is returned to its previous value</li>
<li><a href="architecture/tstack.html">tstack</a> is popped until it is at its previous position</li>
<li>If this is the initial subroutine of an interrupt
<ul>
<li>It is finished servicing</li>
<li>The interrupt <a href="architecture/conveyor.html">conveyor</a> is replaced with the normal <a href="architecture/conveyor.html">conveyor</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>Notes</h4>
<ul>
<li>The <a href="architecture/lstack.html">lstack</a> is NOT returned to its previous state.</li>
</ul>
<h4>Examples</h4>
<pre><code>subr calli
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<pre><code>subr jumpi

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>A more efficient version of the previous example by utilizing tail-call elimination</li>
</ul>
<hr />
<h2><code>calli</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>calli</code> is an immediate call. In this situation, immediate means that the PC to jump to is taken from <code>dc0</code>. This also increments <code>dc0</code> and puts the incremented copy of <code>dc0</code> onto the <a href="architecture/cstack.html">cstack</a>, along with the other state elements preserved in a call.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is pushed
<ul>
<li>DCs are preserved</li>
<li>PC is preserved</li>
<li><a href="architecture/tstack.html">tstack</a> position is preserved</li>
<li>Whether an interrupt is being serviced or not is preserved</li>
</ul>
</li>
</ul>
<h4>Examples</h4>
<pre><code>subr calli
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<hr />
<h2><code>jmpi</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jmpi</code> jumps to an immediate value stored at <code>dc0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value</li>
<li><code>dc0</code> is incremented</li>
</ul>
<hr />
<h2><code>jc</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jc</code> jumps to an immediate value stored at <code>dc0</code> if the <code>c</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>c</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jnc</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jnc</code> jumps to an immediate value stored at <code>dc0</code> if the <code>c</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>c</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jo</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jo</code> jumps to an immediate value stored at <code>dc0</code> if the <code>o</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>o</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jno</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jno</code> jumps to an immediate value stored at <code>dc0</code> if the <code>o</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>o</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>call</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>call</code> calls a subroutine. The address <code>a</code> is the destination the PC is set to. This pushes the <a href="architecture/cstack.html">cstack</a>, storing all the state elements preserved in a call.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is pushed
<ul>
<li>DCs are preserved</li>
<li>PC is preserved</li>
<li><a href="architecture/tstack.html">tstack</a> position is preserved</li>
<li>Whether an interrupt is being serviced or not is preserved</li>
</ul>
</li>
</ul>
<h4>Examples</h4>
<pre><code>subr read0 call
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<hr />
<h2><code>jmp</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>jmp</code> jumps to the address <code>a</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to <code>a</code></li>
</ul>
<hr />
<h2><code>jeq</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>jeq</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> and <code>b</code> are equal. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a == b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jne</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>jne</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> and <code>b</code> are not equal. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a != b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>les</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>les</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than <code>b</code> in a signed comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt; b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>leq</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>leq</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in a signed comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lesu</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lesu</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt; b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lequ</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lequ</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lequ</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lequ</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>loop</code></h2>
<p><code>n e --</code></p>
<h4>Description</h4>
<p><code>loop</code> pushes a new loop into onto the <a href="architecture/lstack.html">lstack</a>. <code>n</code> represents the number of iterations of the loop, while <code>e</code> represents the end address of the loop. The loop index (<code>i0</code>) begins at <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/lstack.html">lstack</a> is pushed</li>
</ul>
<hr />
<h2><code>loopi</code></h2>
<p><code>n --</code></p>
<h4>Description</h4>
<p><code>loopi</code> pushes a new loop into onto the <a href="architecture/lstack.html">lstack</a>. <code>n</code> represents the number of iterations of the loop. The end address is taken from <code>dc0</code> and <code>dc0</code> is incremented. The loop index (<code>i0</code>) begins at <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/lstack.html">lstack</a> is pushed</li>
<li><code>dc0</code> is incremented</li>
</ul>
<h1>UARC Instructions</h1>
<h2><code>ien</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ien</code> enables interrupts in the <a href="architecture/ifile.html">ifile</a> for buses which are presently selected.</p>
<h4>Side Effects</h4>
<ul>
<li>All selected buses now have interrupts enabled.</li>
</ul>
<hr />
<h2><code>idi</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>idi</code> disables all interrupts currently enabled.</p>
<h4>Side Effects</h4>
<ul>
<li>All buses now have interrupts disabled.</li>
</ul>
<hr />
<h2><code>recv</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>recv</code> accepts any interrupt synchronously without an interrupt handler from any selected bus. The bus ID and the interrupt value are added to the <a href="architecture/conveyor.html">conveyor</a> in that order.</p>
<h4>Side Effects</h4>
<ul>
<li><code>cv &lt;- bus, v</code></li>
<li>Synchronizes execution with the next interrupt</li>
</ul>
<hr />
<h2><code>in</code></h2>
<p><code>a -- b</code></p>
<h4>Description</h4>
<p><code>in</code> receives a stream from any selected UARC bus. <code>a</code> is the address at which those words are to be streamed to. <code>b</code> is the bus ID of the particular bus that streamed these values.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the completion of the stream operation</li>
</ul>
<hr />
<h2><code>kill</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>kill</code> causes every single core connected to every selected bus and every single one of their children to stop before the instruction completes. This instruction takes <code>2 * n</code> cycles, where <code>n</code> is the depth of the longest chain of incepted cores. This will not succeed unless the core has <a href="uarc.html">permission</a> over the target cores. If the target does not have the proper <a href="uarc.html">permission</a>, it will report success without doing anything.</p>
<h4>Side Effects</h4>
<ul>
<li>All selected cores for which this core has permission will be stopped before this instruction finishes.</li>
</ul>
<hr />
<h2><code>getp</code></h2>
<p><code>-- priv</code></p>
<h4>Description</h4>
<p><code>getp</code> places the <a href="uarc.html">privilege</a> of the current core on the stack. This value will range from <code>0</code> to <code>31</code>.</p>
<hr />
<h2><code>geta</code></h2>
<p><code>-- addr</code></p>
<h4>Description</h4>
<p><code>geta</code> places the <a href="uarc.html">address</a> of the current core on the stack. This value is 31 bits and will be placed in the least significant bits of the word.</p>
<h4>Notes</h4>
<ul>
<li>This instruction is not supported for a <code>WORD</code> that is less than 32 bits.</li>
</ul>
<hr />
<h2><code>seb</code></h2>
<p><code>b --</code></p>
<h4>Description</h4>
<p><code>seb</code> clears all buses from being selected and then sets a specific set of UARC buses to be selected. The upper <code>WORD/2</code> bits of <code>b</code> select randomly from a register file of select registers and the lower <code>WORD/2</code> bits are a mask that represent which bits to specifically assign to that select register.</p>
<h4>Side Effects</h4>
<ul>
<li>Specific UARC buses are now selected.</li>
</ul>
<hr />
<h2><code>slb</code></h2>
<p><code>b --</code></p>
<h4>Description</h4>
<p><code>seb</code> selects a specific set of UARC buses. The upper <code>WORD/2</code> bits of <code>b</code> select randomly from a register file of select registers and the lower <code>WORD/2</code> bits are a mask that represent which bits to specifically OR to that select register.</p>
<h4>Side Effects</h4>
<ul>
<li>Specific UARC buses are now added to the selection.</li>
</ul>
<hr />
<h2><code>iset</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>iset</code> sets the interrupt address of all selected UARC buses to <code>a</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>Any further interrupts on the selected UARC buses now call the routine at <code>a</code>.</li>
</ul>
<hr />
<h2><code>send</code></h2>
<p><code>v --</code></p>
<h4>Description</h4>
<p><code>send</code> sends a value to all selected UARC buses, and waits for all buses to accept the interrupt before continuing.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the acceptance of all interrupts sent.</li>
</ul>
<hr />
<h2><code>out</code></h2>
<p><code>n a --</code></p>
<h4>Description</h4>
<p><code>out</code> sends a stream to all selected UARC buses. <code>n</code> is the number of words able to be streamed out and <code>a</code> is the address at which those words are to be streamed from.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the completion of the stream operation.</li>
</ul>
<hr />
<h2><code>setp</code></h2>
<p><code>priv addr --</code></p>
<h4>Description</h4>
<p><code>setp</code> sets the <a href="uarc.html">permission</a> that is to be delegated to all incepted UARC cores. This value defaults to the same <a href="uarc.html">permission</a> that this core receives on inception. If the user attempts to set a <a href="uarc.html">permission</a> that the core doesn't have access to, this instruction will fail without warning.</p>
<h4>Side Effects</h4>
<ul>
<li>All cores incepted after this instruction is executed will have this <a href="uarc.html">permission</a>.</li>
</ul>
<h1>UARC</h1>
<p>c0 is an official UARC ISA. The purpose of UARC is to make it trivial to combine cores that are specialized at performing their function, so as to alleviate the process of providing backwards compatibility and to provide better utilization. The purpose of c0 is somewhat counter to the purpose of UARC: to provide a general purpose architecture. c0 is designed to be an architecture with high instruction density and the capability to quickly respond to communications from other more-specialized cores. To this end its entire architecture is designed, down to the stack architecture that lets it immediately respond to interrupts.</p>
<p>c0, as a reference UARC implementation, must provide all standard UARC facilities. It must allow multicast interrupts and data streaming. It must also allow privilege delegation. Message passing is facilitated by sending words over the UARC bus or sending a stream over the UARC bus. Sending an interrupt to a core that is not running will cause the interrupt to wait for the core to accept the interrupt by starting. Sending a stream to a target that is currently not running will cause permissions to be delegated to that core and for the core to begin running the program streamed to it.</p>
<p>UARC permissions work in a hierarchy. If a core has incepted a core, it also has <strong>permission</strong> over all the cores incepted by that core. This means that any children cores can be stopped using the <code>kill</code> instruction. Such delegation allows an operating system to not only stop execution of processes, but also delegate permissions to those processes. To achieve this delegation capability, cores continuously share their <strong>permission</strong> with all targets. This is achieved by using a 5-bit bus with the <strong>privilege</strong> of the core, and a 31-bit bus displaying the <strong>address</strong> of the core. The only parts of the <strong>address</strong> that are relevant are those masked by the <strong>privilege</strong>, known as the <strong>permission</strong> of the core. A <strong>privilege</strong> of 0 indicates that a core has absolute <strong>permission</strong> over all cores, including all cores that are of the same privilege level. If the privilege level is 31, then all 31 <strong>address</strong> bits encode the <strong>permission</strong> of the core, which means such a core can only <code>kill</code> cores the exact same <strong>permission</strong>.</p>
<p>It is permitted for any core to attempt communications with any other core, regardless of either of their <strong>permission</strong>. However, some cores may have specific schemes to accept or reject communications based on a communicating core's delegated <strong>permission</strong>. For instance, a core might have a table of <strong>permission</strong> values that allow it to filter communications based on a core's parents. In c0, such elaborate systems must be implemented in software, but programmers should be aware that other systems might be capable of this.</p>
<p><code>kill</code> is a simple instruction, but it has a complicated result. All child cores of the core being killed must also be killed. To achieve this, the UARC bus has two lines. One line is for sending a kill signal and the other is for acknowledging completion. As soon as a core knows all children are stopped, it may assert the acknowledge line and stop on the next cycle. A core with no children may immediately assert the acknowledge line and stop as soon as possible, since it has already met the above condition. A side effect of the setup is that the kill signal will also take one cycle to propagate down through each core. It takes <code>2 * n</code> cycles to complete the <code>kill</code> instruction, depending on the depth of inception (<code>n</code>).</p>
<p>A corner case is that a core may try to send a kill signal to a core for which it doesn't have <strong>permission</strong> to kill. In this case, the core should acknowledge immediately without doing anything to prevent deadlock. Also, any core which is already killed should continue to assert the acknowledge line to prevent deadlock in the case that the core is not even running. This also allows cores to know when another core is no longer running, though c0 is not capable of detecting this.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
