<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>UARC core0</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="overview.html"><strong>1.</strong> Overview</a></li><li><a href="architecture.html"><strong>2.</strong> Architecture</a></li><li><ul class="section"><li><a href="architecture/registers.html"><strong>2.1.</strong> Registers</a></li><li><a href="architecture/dstack.html"><strong>2.2.</strong> dstack</a></li><li><a href="architecture/cstack.html"><strong>2.3.</strong> cstack</a></li><li><a href="architecture/lstack.html"><strong>2.4.</strong> lstack</a></li><li><a href="architecture/ifile.html"><strong>2.5.</strong> ifile</a></li><li><a href="architecture/conveyor.html"><strong>2.6.</strong> conveyor</a></li></ul></li><li><a href="instruction_reference.html"><strong>3.</strong> Instruction Reference</a></li><li><ul class="section"><li><a href="instruction_reference/arithmetic.html"><strong>3.1.</strong> Arithmetic</a></li><li><a href="instruction_reference/bit_manipulation.html"><strong>3.2.</strong> Bit Manipulation</a></li><li><a href="instruction_reference/stack_manipulation.html"><strong>3.3.</strong> Stack Manipulation</a></li><li><a href="instruction_reference/memory.html"><strong>3.4.</strong> Memory</a></li><li><a href="instruction_reference/control_flow.html"><strong>3.5.</strong> Control Flow</a></li><li><a href="instruction_reference/uarc.html"><strong>3.6.</strong> UARC</a></li></ul></li><li><a href="uarc.html"><strong>4.</strong> UARC</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">UARC core0</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Overview</h1>
<p>UARC core0 (c0) is the primary general purpose ISA for the UARC standardized core collection. Although it is an ISA, a reference implementation is provided via emulator and SystemVerilog.</p>
<p>This architecture is targeted towards small size and efficiency in shuffling data around across the UARC bus. No floating point instructions are included since it is expected that such algorithms will not run on core0, but will instead be offloaded to another UARC compatible core with floating point support. Due to the nature of UARC, it is possible to implement floating point operations using a coprocessor that connects over the UARC bus if desired.</p>
<p>It is important to note that although this core can be used for an OS that spreads across multiple UARC cores, it is not intended to be the target of user space applications, except where those applications need to shuffle data around between UARC cores or only require integer arithmetic. c0 demonstrates the UARC principle while simultaneously acting as a mediator of data between UARC cores.</p>
<p>c0's ISA is designed to use whatever word size is required, but it is intended to be used as a 32-bit architecture.</p>
<h1>Architecture</h1>
<h3>Status</h3>
<table><thead><tr><td>Symbol</td><td>Purpose</td></tr></thead>
<tr><td><code>c</code></td><td>Carry bit</td></tr>
<tr><td><code>o</code></td><td>Overflow bit</td></tr>
<tr><td><code>i</code></td><td>Interrupt bit</td></tr>
</table>
<p>c0 is a stack machine, meaning that all parameters are implicit and all destinations are implicit except for stack manipulation and memory access. For comparison, belt machines have an implicit destination and register machines (the most common) have explicit parameters and destination. This means that for many instructions, a stack machine's instruction is entirely composed of an opcode with no extra fields.</p>
<p>Since no task switching is required in c0, it is not necessary to be concerned with the amount of state elements in the architecture, except where those elements require random access. Due to this, several stacks are present in the architecture aside from the main stack on which most of the processing occurs: the <a href="architecture/dstack.html">dstack</a>. For instance, the architecture also has a dedicated <a href="architecture/cstack.html">call stack</a> so that parameters can be passed on the <a href="architecture/dstack.html">dstack</a> orderly to a called routine and be consumed without worrying about the return address. A zero-overhead loop unit is also present that allows automatic conditional branching back to the beginning of the inner-most loop. The stack that contains the various loop parameters is called the <a href="architecture/lstack.html">loop stack</a>.</p>
<p>Not all stacks present in c0 are Last-In First-Out (LIFO). The <a href="architecture/dstack.html">dstack</a> itself has dedicated copy and rotate instructions so that it is possible to copy or move things to the top of the stack. The <a href="architecture/dstack.html">dstack</a> copy instruction is intended to allow variables to be computed once and copied into place on the stack however many additional times they are required before the final value is consumed. The rotate instruction is used when it cannot be satisfied that an accumulator will be on the top of the stack when it must be accumulated to during a loop. Rotate may also need to be used in conditional branching when different branch paths do not consume values from the stack in the same order. Branch paths that are more likely to be taken should avoid the rotate instruction and rotates should be added to the less-likely path.</p>
<p>Finally, the <a href="architecture/ifile.html">ifile</a> is a register file containing the interrupt address, enable bit, and selection bit that corresponds to each UARC bus present on the core. Each of the interrupts can be individually enabled, disabled, and set. Using the selection mechanism, several addresses can be enabled, disabled, and set simultaneously to avoid wasting time setting up interrupts or sending/receiving messages to/from multiple targets.</p>
<h1>Registers</h1>
<table><thead><tr><td>Name</td><td>Purpose</td></tr></thead>
<tr><td><code>PC</code></td><td>The location of the presently executing instruction</td></tr>
<tr><td><code>DC#</code></td><td>4 locations data can be used and stored in order; also can be made into stacks</td></tr>
<tr><td><code>i</code></td><td>A status bit that conveys if an interrupt has been handled since last checked</td></tr>
<tr><td><code>c</code></td><td>A status bit for arithmetic carry</td></tr>
<tr><td><code>o</code></td><td>A status bit for overflow</td></tr>
</table>
<h1>dstack</h1>
<p>The <strong>dstack</strong> is the primary stack on which all operations take place. This stack is the only stack that can be rotated and copied in one cycle. If the <strong>dstack</strong> is rotated, all elements below the selected element will not shift down, but all elements above it will shift down and the selected element will be placed on the top. If the <strong>dstack</strong> is copied, all elements move down and the copied element is moved to the top.</p>
<p>All elements on the <strong>dstack</strong> are capable of being pushed once, doing nothing, popping once, or popping twice. What happens to the <strong>dstack</strong> is explicitly encoded in the <code>[6:5]</code> bits of the instruction for all instructions for which the <code>[7]</code> bit is <code>0</code>. More importantly, when the stack is rotated or copied, the <code>[5:0]</code> bits are used to encode the location to perform the operation on, which makes it quick for the instruction to be decoded.</p>
<p>The <strong>dstack</strong> is where almost all parameters should be passed into functions and where almost all parameters should be returned from functions. Should a function need to access a loop index explicitly as a constant parameter, it can safely use loop index instructions. Information may also be passed into functions via the status bits. Except when programming manually using assembly, the compiler should not generate code that passes information using any method described above. If the compiler wishes to achieve a speed-up by preserving the DCs across the call, it should be implemented as an inline expansion of the function.</p>
<h1>cstack</h1>
<table><thead><tr><td>State</td><td>Result on Pop</td></tr></thead>
<tr><td>PC</td><td>Moves PC back to location in caller after the jump/call</td></tr>
<tr><td>DCs</td><td>Restores all DCs to previous locations</td></tr>
<tr><td>DC modifications</td><td>Tracks if the DCs were set in the previous call</td></tr>
<tr><td>DC directions</td><td>The direction the DCs move when written</td></tr>
<tr><td>interrupt</td><td>Set the <code>i</code> flag to allow checks for interrupt handling</td></tr>
</table>
<p>The cstack is a call stack that contains state information required to return from a subroutine call. This includes things such as the PC, the DCs, and if the last call was to an interrupt. The status bits are not preserved in a call. If an interrupt is issued and accepted or either of the call instructions are executed, the cstack will be pushed. Any time a return instruction is executed, the cstack is popped. The cstack should be accessable on a single-cycle notice and thus should exist in processor memory. Because it is only pushed and popped in regular amounts, it deserves a place on-die as its own processor element, though this is not absolutely necessary, and the stack can be spilled into main memory if the need arises.</p>
<p>If the cstack is pushed due to an interrupt, the interrupt bit is set on the cstack so that the interrupt flag can be appropriately set on a return from the interrupt and so that the processor can internally switch the mode back for the <a href="conveyor.html">conveyor</a>. The cstack also tracks if new DCs are set by this subroutine. If any particular DC is set in the subroutine, a flag is set which indicates this, and on returning from the subroutine the previous DC is restored. However, if the flag is not set, then the DC is not restored. The purpose of this is to allow a subroutine to use the DC of the parent caller and upon returning to the parent continue where the child left off. This is important for inlining functions and allowing a child to consume part of a vector pointed to by a DC. In all other cases, if the child sets its own DC, it is necessary to restore the DCs to their previous locations.</p>
<h1>lstack</h1>
<p>The <strong>lstack</strong> is a stack with architecture-dependent depth which allows the initialization of loops with zero-overhead. This means that no instruction is wasted checking for loop bounds and no hardware is needed to do branch prediction for loop bounds. Additionally, for the stack processor it means that the loop index is easily obtainable in one instruction for the top four loops. Only the very top loop is checked for its bounds, so the end of a loop that is not on top of the stack should never be encountered.</p>
<h1>ifile</h1>
<p>The ifile is a register file present in c0 that holds state information about each UARC bus connected to the core. The most important thing the ifile holds is if a given port is enabled, has interrupts enabled, the interrupt address, and the <code>dc0</code> to set on an interrupt to that bus. These things can all be accessed through the <a href="instruction_reference/uarc.html">UARC instructions</a> on the c0.</p>
<h1>conveyor</h1>
<p>The conveyor is a processor element found in belt machines in which the destination register does not need to be specified, but the parameters do. Since we are embedding the conveyor into a stack processor, operations occasionally consume parameters from the stack in defined positions and place the result on the conveyor so that it can be retrieved when desired. This allows for two things: It allows asynchronous operations to be synchronized when desired and it allows operations that have multiple outputs to provide their results on the stack in the correct positions.</p>
<p>As was stated, the conveyor is capable of synchronizing asynchronous operations. For instance, if a division is executed, the result will be placed onto the conveyor, but that doesn't mean it is completed. If the programmer attempts to read the value from the conveyor, it will trigger a synchronization that waits until the division is complete before reading the value from the conveyor.</p>
<p>Since the conveyor only moves in one direction, when an interrupt is received the conveyor could not be used. This is solved by having an alternate conveyor for interrupts. Since asynchronous operations enter a FIFO queue, operations from before the interrupt is handled may still have to complete before the interrupt can be handled. As these operations finish, they will place their results into the main conveyor's dedicated registers, allowing the interrupt to process asynchronous operations. Some operations use a pipeline and therefore will still finish in constant time, such as multiplication and division. Other operations will have to be waited on, such as random asynchronous memory reads, which can only be processed sequentially, except if they were already in cache.</p>
<h1>Instruction Reference</h1>
<h3>c0 Instruction Formats</h3>
<ul>
<li>
<p><code>OOOO OOOO</code> (All instructions)</p>
<ul>
<li><code>0SSO OOOO</code> (Normal instructions)
<ul>
<li>All normal instructions affect the entire stack according to the <code>S</code> bits</li>
<li><code>0010 LLLL</code> (Conveyor instruction)
<ul>
<li>Reads and synchronizes with conveyor index <code>location</code></li>
</ul>
</li>
<li><code>0011 10LL</code> (Loop index)
<ul>
<li>Places the index from the loop of depth <code>location</code> on the <a href="architecture/dstack.html">dstack</a></li>
</ul>
</li>
<li><code>0SSO OOLL</code> (DC instructions)
<ul>
<li>Operates using specifically the DC of index <code>location</code></li>
</ul>
</li>
</ul>
</li>
<li><code>1OLL LLLL</code> (Random access instructions)
<ul>
<li><code>10LL LLLL</code> (Rotate)
<ul>
<li><a href="architecture/dstack.html">dstack</a> item of depth <code>location + 1</code> rotated to top of <a href="architecture/dstack.html">dstack</a></li>
<li>Only elements above the rotate are pushed down</li>
</ul>
</li>
<li><code>11LL LLLL</code> (Copy)
<ul>
<li><a href="architecture/dstack.html">dstack</a> item of depth <code>location + 1</code> copied to top of <a href="architecture/dstack.html">dstack</a></li>
<li>Entire stack is pushed down</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>O</code> - Opcode bit</p>
</li>
<li>
<p><code>S</code> - Stack bit</p>
</li>
<li>
<p><code>L</code> - Location bit</p>
</li>
</ul>
<h3>Stack bits</h3>
<ul>
<li><code>00</code> - The stack is not popped or pushed.</li>
<li><code>01</code> - The stack is pushed once.</li>
<li><code>10</code> - The stack is popped once.</li>
<li><code>11</code> - The stack is popped twice.</li>
</ul>
<h2>Key</h2>
<ul>
<li><code>WORD</code> - Data word width in use</li>
<li><code>c</code> - Carry bit</li>
<li><code>cv</code> - <a href="architecture/conveyor.html">Conveyor Belt</a></li>
<li><code>dc[0-3]</code> - Data Counters</li>
<li><code>pc</code> - Program Counter</li>
<li><code>iflag</code> - Interrupt Flag</li>
<li><code>i[0-3]</code> - Loop Indices</li>
<li><code>cv[0-F]</code> - <a href="architecture/conveyor.html">Conveyor Belt</a> Values</li>
<li><code>ls</code> - <a href="architecture/lstack.html">lstack</a></li>
<li><code>if</code> - <a href="architecture/ifile.html">ifile</a></li>
<li><code>n..</code> - <code>n</code> anonymous words on the stack</li>
</ul>
<h2>Instruction Listing By Opcode</h2>
<table><thead><tr><td>Op</td><td>Instruction</td><td>dstack</td><td>Side Effects</td></tr></thead>
<tr><td><code>00</code> - <code>03</code></td><td>rread#</td><td><code>a -- mem[dc# + a]</code></td></tr>
<tr></tr>
<tr><td><code>04</code> - <code>07</code></td><td>add#</td><td><code>a -- (a + mem[dc#])</code></td><td>dc# advances; <code>c</code>, <code>o</code></td></tr>
<tr><td><code>08</code></td><td>inc</td><td><code>a -- (a + 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>09</code></td><td>dec</td><td><code>a -- (a - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>0A</code></td><td>carry</td><td><code>v -- (v + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>0B</code></td><td>borrow</td><td><code>v -- (v + c - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>0C</code></td><td>inv</td><td><code>v -- ~v</code></td><td> </td></tr>
<tr><td><code>0D</code></td><td>break</td><td><code>--</code></td><td>Pops the lstack and goes to end of loop</td></tr>
<tr><td><code>0E</code></td><td>reads</td><td><code>a -- mem[a]</code></td><td>Synchronous read</td></tr>
<tr><td><code>0F</code></td><td>ret</td><td><code>--</code></td><td>Pops <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>10</code></td><td>continue</td><td><code>--</code></td><td>Goes to the next loop iteration</td></tr>
<tr><td><code>11</code></td><td>ien</td><td><code>--</code></td><td>Enables only selected interrupts</td></tr>
<tr><td><code>12</code></td><td>recv</td><td><code>--</code></td><td>Interrupt sync; <code>cv &lt;- bus, v</code></td></tr>
<tr><td><code>13</code></td><td>ldi0</td><td><code>--</code></td><td>dc0 = mem[dc0]; preserve dc0</td></tr>
<tr><td><code>14</code></td><td>kill</td><td><code>--</code></td><td>Kill all selected cores</td></tr>
<tr><td><code>15</code></td><td>wait</td><td><code>--</code></td><td>Waits for an interrupt before continuing</td></tr>
<tr><td><code>16</code></td><td>getbp</td><td><code>b -- perm</code></td><td>Gets the <a href="uarc.md">permission</a> on bus <code>b</code></td></tr>
<tr><td><code>17</code></td><td>getba</td><td><code>b -- addr</code></td><td>Gets the <a href="uarc.md">address</a> on bus <code>b</code></td></tr>
<tr><td><code>18</code></td><td>calli</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code>; push <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>19</code></td><td>jmpi</td><td><code>--</code></td><td><code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1A</code></td><td>jc</td><td><code>--</code></td><td>if <code>c</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1B</code></td><td>jnc</td><td><code>--</code></td><td>if <code>~c</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1C</code></td><td>jo</td><td><code>--</code></td><td>if <code>o</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1D</code></td><td>jno</td><td><code>--</code></td><td>if <code>~o</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1E</code></td><td>ji</td><td><code>--</code></td><td>if <code>iflag</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>1F</code></td><td>jni</td><td><code>--</code></td><td>if <code>~iflag</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>20</code> - <code>2F</code></td><td>cv#</td><td><code>-- cv#</code></td><td>cv# synchronizes</td></tr>
<tr><td><code>30</code> - <code>33</code></td><td>read#</td><td><code>-- mem[dc#]</code></td><td>dc# advances</td></tr>
<tr><td><code>34</code> - <code>37</code></td><td>get#</td><td><code>-- dc#</code></td><td> </td></tr>
<tr><td><code>38</code> - <code>3B</code></td><td>i#</td><td><code>-- i#</code></td><td> </td></tr>
<tr><td><code>3C</code></td><td>p0</td><td><code>-- 0</code></td><td> </td></tr>
<tr><td><code>3D</code></td><td>dup</td><td><code>v -- v v</code></td><td> </td></tr>
<tr><td><code>3E</code></td><td>getp</td><td><code>-- perm</code></td><td>Get UARC permission</td></tr>
<tr><td><code>3F</code></td><td>geta</td><td><code>-- addr</code></td><td>Get UARC address</td></tr>
<tr><td><code>40</code> - <code>43</code></td><td>write#</td><td><code>v --</code></td><td><code>mem[dc#] = v</code>; dc# advances</td></tr>
<tr><td><code>44</code> - <code>47</code></td><td>setf#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write post-inc</td></tr>
<tr><td><code>48</code> - <code>4B</code></td><td>setb#</td><td><code>a --</code></td><td><code>dc# = a</code>; dc# is write pre-dec</td></tr>
<tr><td><code>4C</code></td><td>add</td><td><code>a b -- (a + b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4D</code></td><td>addc</td><td><code>a b -- (a + b + c)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4E</code></td><td>sub</td><td><code>a b -- (a - b)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>4F</code></td><td>subc</td><td><code>a b -- (a - b + c - 1)</code></td><td><code>c</code>, <code>o</code></td></tr>
<tr><td><code>50</code></td><td>lsl</td><td><code>a b -- (a &lt;&lt; b)</code></td></tr>
<tr></tr>
<tr><td><code>51</code></td><td>lsr</td><td><code>a b -- (a &gt;&gt; b)</code></td></tr>
<tr></tr>
<tr><td><code>52</code></td><td>csl</td><td><code>a b -- ((a &lt;&lt; b) or (a &gt;&gt; (b - WORD)))</code></td><td> </td></tr>
<tr><td><code>53</code></td><td>csr</td><td><code>a b -- ((a &gt;&gt; b) or (a &lt;&lt; (b - WORD)))</code></td><td> </td></tr>
<tr><td><code>54</code></td><td>asr</td><td><code>a b -- (a &gt;&gt;&gt; b)</code></td></tr>
<tr></tr>
<tr><td><code>55</code></td><td>and</td><td><code>a b -- (a &amp; b)</code></td><td> </td></tr>
<tr><td><code>56</code></td><td>or</td><td><code>a b -- (a or b)</code></td><td> </td></tr>
<tr><td><code>57</code></td><td>xor</td><td><code>a b -- (a ^ b)</code></td><td> </td></tr>
<tr><td><code>58</code></td><td>reada</td><td><code>a --</code></td><td><code>cv &lt;- mem[a]</code></td></tr>
<tr><td><code>59</code></td><td>call</td><td><code>a --</code></td><td><code>pc = a</code>; push <a href="architecture/cstack.html">cstack</a></td></tr>
<tr><td><code>5A</code></td><td>jmp</td><td><code>a --</code></td><td><code>pc = a</code></td></tr>
<tr><td><code>5B</code></td><td>iset</td><td><code>d --</code></td><td>Set selected interrupt addresses and dc0s</td></tr>
<tr><td><code>5C</code></td><td>slb</td><td><code>b --</code></td><td>Select an additional UARC bus</td></tr>
<tr><td><code>5D</code></td><td>usb</td><td><code>b --</code></td><td>Unselect a UARC bus</td></tr>
<tr><td><code>5E</code></td><td>send</td><td><code>v --</code></td><td>Send value to selected buses</td></tr>
<tr><td><code>5F</code></td><td>loopi</td><td><code>n --</code></td><td><code>ls &lt;- n, dc0, 0</code></td></tr>
<tr><td><code>60</code> - <code>63</code></td><td>rwrite#</td><td><code>v a --</code></td><td><code>mem[dc# + a] = v</code></td></tr>
<tr><td><code>64</code></td><td>write</td><td><code>v a --</code></td><td><code>mem[a] = v</code></td></tr>
<tr><td><code>65</code></td><td>jeq</td><td><code>a b --</code></td><td>if <code>a == b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>66</code></td><td>jne</td><td><code>a b --</code></td><td>if <code>a != b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>67</code></td><td>les</td><td><code>a b --</code></td><td>if <code>a &lt; b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>68</code></td><td>leq</td><td><code>a b --</code></td><td>if <code>a &lt;= b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>69</code></td><td>lesu</td><td><code>a b --</code></td><td>if <code>a &lt; b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>6A</code></td><td>lequ</td><td><code>a b --</code></td><td>if <code>a &lt;= b</code> then <code>dc0 -&gt; pc</code></td></tr>
<tr><td><code>6B</code></td><td>in</td><td><code>n a --</code></td><td>Stream in to <code>a</code>; <code>cv &lt;- bus</code></td></tr>
<tr><td><code>6C</code></td><td>out</td><td><code>n a --</code></td><td>Stream n words to buses from a</td></tr>
<tr><td><code>6D</code></td><td>incept</td><td><code>n a --</code></td><td>Incept target cores; same as out</td></tr>
<tr><td><code>6E</code></td><td>set</td><td><code>m s --</code></td><td>Clear ifile and set register <code>s</code> to <code>m</code></td></tr>
<tr><td><code>6F</code></td><td>sel</td><td><code>m s --</code></td><td>Ors <code>m</code> with register <code>s</code> of ifile</td></tr>
<tr><td><code>70</code></td><td>seta</td><td><code>perm addr --</code></td><td>Sets UARC permission and address delegation</td></tr>
<tr><td><code>71</code></td><td>loop</td><td><code>n e --</code></td><td><code>ls &lt;- n, e, 0</code></td></tr>
<tr><td><code>72</code></td><td>sef</td><td><code>a f --</code></td><td>Sets fault <code>f</code> handler to <code>a</code></td></tr>
<tr><td><code>73</code></td><td>mul</td><td><code>a b --</code></td><td><code>cv &lt;- low(a * b), high(a * b)</code></td></tr>
<tr><td><code>74</code></td><td>mulu</td><td><code>a b --</code></td><td><code>cv &lt;- low(a * b), high(a * b)</code></td></tr>
<tr><td><code>75</code></td><td>div</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
<tr><td><code>76</code></td><td>divu</td><td><code>a b --</code></td><td><code>cv &lt;- a / b, a % b</code></td></tr>
<tr><td><code>80</code> - <code>BF</code></td><td>rot#</td><td><code>v (# + 1).. -- (# + 1).. v</code></td><td> </td></tr>
<tr><td><code>C0</code> - <code>FF</code></td><td>copy#</td><td><code>v (# + 1).. -- v (# + 1).. v</code></td><td> </td></tr>
</table>
<h1>Arithmetic Instructions</h1>
<h2><code>add#</code></h2>
<p><code>a -- (a + mem[dc#])</code></p>
<h4>Description</h4>
<p><code>add#</code> adds the top of the <a href="architecture/dstack.html">dstack</a> with the immediate value from <code>dc#</code>. The <code>o</code> and <code>c</code> bits are set, but not consumed. <code>dc#</code> is incremented.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + mem[dc#])[WORD]</code></li>
<li><code>o = (a[WORD - 1] ^ mem[dc#][WORD - 1]) ? 0 : a[WORD - 1] ^ (a + mem[dc#])[WORD - 1]</code></li>
</ul>
<hr />
<h2><code>inc</code></h2>
<p><code>a -- (a + 1)</code></p>
<h4>Description</h4>
<p><code>inc</code> increments the top of the <a href="architecture/dstack.html">dstack</a> by 1. The overflow and carry bits are set, but not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + 1 == 0)</code></li>
<li><code>o = (a + 1 == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>h7FFFFFFF inc
</code></pre>
<ul>
<li><code>( -- h80000000)</code></li>
<li><code>o</code> is set to 1 because a positive number became negative by wrapping</li>
<li><code>c</code> is set to 0</li>
</ul>
<hr />
<h2><code>dec</code></h2>
<p><code>a -- (a + 1)</code></p>
<h4>Description</h4>
<p><code>dec</code> decrements the top of the <a href="architecture/dstack.html">dstack</a> by 1. The overflow and carry bits are set, but not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a - 1 != ~0)</code></li>
<li><code>o = (a == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 dec
</code></pre>
<ul>
<li><code>( -- -1)</code></li>
<li><code>o</code> is set to 0 because no overflow occurred</li>
<li><code>c</code> is set to 1 because a borrow was incurred</li>
</ul>
<hr />
<h2><code>carry</code></h2>
<p><code>a -- (a + c)</code></p>
<h4>Description</h4>
<p><code>carry</code> is used when the carry bit needs to be accumulated to a more significant word after a less significant operation. It affects the <code>o</code> and <code>c</code> similarly to <code>inc</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = c == 1 &amp;&amp; (a + c == 0)</code></li>
<li><code>o = c == 1 &amp;&amp; (a == -1)</code></li>
</ul>
<h4>Examples</h4>
<pre><code>~0 inc
0 carry
</code></pre>
<ul>
<li><code>( -- 0 1)</code></li>
<li><code>c</code> is set to 0</li>
<li><code>o</code> is set to 0</li>
</ul>
<hr />
<h2><code>borrow</code></h2>
<p><code>a -- (a + c - 1)</code></p>
<h4>Description</h4>
<p><code>borrow</code> is used when a borrow must be applied to a more significant word after a less significant operation. It affects the <code>o</code> and <code>c</code> bits similarly to <code>dec</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = c == 1 || (a - 1 != ~0)</code></li>
<li><code>o = c == 1 || (a == 1 &lt;&lt; (WORD - 1))</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 dec
1 borrow
</code></pre>
<ul>
<li><code>( -- 0 0)</code></li>
<li><code>c</code> is set to 0</li>
<li><code>o</code> is set to 0</li>
</ul>
<hr />
<h2><code>add</code></h2>
<p><code>a b -- (a + b)</code></p>
<h4>Description</h4>
<p><code>add</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them. The carry bit is set by this instruction, but is not consumed.</p>
<h4>Side Effects</h4>
<ul>
<li><code>c = (a + b)[WORD]</code></li>
<li><code>o = (a[WORD - 1] ^ b[WORD - 1]) ? 0 : a[WORD - 1] ^ (a + b)[WORD - 1]</code></li>
</ul>
<h4>Examples</h4>
<pre><code>2 3 add
</code></pre>
<ul>
<li><code>( -- 5)</code></li>
<li>Carry is set to 0</li>
</ul>
<hr />
<h2><code>addc</code></h2>
<p><code>a b -- (a + b + c)</code></p>
<h4>Description</h4>
<p><code>addc</code> takes parameters <code>a</code> and <code>b</code> from the stack and adds them with <code>c</code>. Unlike <code>add</code>, <code>addc</code> consumes the carry, so ensure it is correctly set before issuing this instruction.</p>
<h4>Side Effects</h4>
<p><code>c = (a + b)[WORD]</code></p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 h80000000 add
0 0 addc
</code></pre>
<ul>
<li><code>( -- 0 1)</code></li>
<li>Carry is set to 0</li>
</ul>
<hr />
<h2><code>sub</code></h2>
<p><code>a b -- (a - b)</code></p>
<h4>Description</h4>
<p><code>sub</code> subtracts parameter <code>b</code> from <code>a</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs. The carry bit is not consumed by this instruction.</p>
<h4>Side Effects</h4>
<p><code>c = (a - b)[WORD]</code></p>
<h4>Examples</h4>
<pre><code>2 3 sub
</code></pre>
<ul>
<li><code>( -- -1)</code></li>
<li>Carry is set to 0
<ul>
<li>Which indicates a borrow</li>
</ul>
</li>
</ul>
<hr />
<h2><code>subc</code></h2>
<p><code>a b -- (a - b + c - 1)</code></p>
<h4>Description</h4>
<p><code>subc</code> subtracts parameter <code>b</code> from <code>a</code> and adds <code>c</code>. The carry bit is set by this instruction to <code>1</code> when no borrow occurs.</p>
<h4>Side Effects</h4>
<p><code>c = (a - b)[WORD]</code></p>
<h4>Examples</h4>
<pre><code>2 3 sub
1 0 subc
</code></pre>
<ul>
<li><code>( -- -1 0)</code></li>
<li>Carry is set to 1 (indicating no borrow)</li>
</ul>
<hr />
<h2><code>asr</code></h2>
<p><code>a b -- (a &gt;&gt;&gt; b)</code></p>
<h4>Description</h4>
<p><code>asr</code> shifts <code>a</code> by <code>b</code> bits and sign extends the result. If <code>-1</code> is shifted right, it will continue to stay <code>-1</code>.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 1 asr
</code></pre>
<ul>
<li><code>( -- hC000000)</code></li>
</ul>
<hr />
<h2><code>mul</code></h2>
<p><code>a b -- (a * b)</code></p>
<h4>Description</h4>
<p><code>mul</code> multiplies two signed numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The lower <code>WORD</code> and the higher <code>WORD</code> bits (both including a sign bit) are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The lowest <code>WORD</code> and highest <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
<li><code>o</code> is <code>1</code> if any significant bits are placed into the conveyor</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 2 mul cv1 cv0
</code></pre>
<ul>
<li><code>( -- h80000000 hFFFFFFFE)</code></li>
</ul>
<hr />
<h2><code>mulu</code></h2>
<p><code>a b -- (a * b)</code></p>
<h4>Description</h4>
<p><code>mulu</code> multiplies two unsigned numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The lower <code>WORD</code> and higher <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The lowest <code>WORD</code> and highest <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples</h4>
<pre><code>~0 2 mul cv1 cv0
</code></pre>
<ul>
<li><code>( -- ~0 1)</code></li>
</ul>
<hr />
<h2><code>div</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>div</code> divides two signed numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The higher/whole <code>WORD</code> and the lower/fractional <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>. Both the higher and the lower results are signed.</p>
<h4>Side Effects</h4>
<ul>
<li>The higher/whole <code>WORD</code> and lower/fractional <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>h80000000 2 div cv1 cv0
</code></pre>
<ul>
<li><code>( -- hC0000000 hBFFFFFFF)</code></li>
</ul>
<hr />
<h2><code>divu</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>divu</code> divides two unsigned numbers (<code>a</code> and <code>b</code>) with width <code>WORD</code> and produces a result with width <code>2 * WORD</code>. The higher/whole <code>WORD</code> and the lower/fractional <code>WORD</code> bits of the result are placed on the <a href="architecture/conveyor.html">conveyor</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>The higher/whole <code>WORD</code> and lower/fractional <code>WORD</code> bits are placed onto the <a href="architecture/conveyor.html">conveyor</a> in that order</li>
</ul>
<h4>Examples (with WORD of 32)</h4>
<pre><code>~0 2 divu cv1 cv0
</code></pre>
<ul>
<li><code>( -- h7FFFFFFF h80000000)</code></li>
</ul>
<h1>Bit Manipulation</h1>
<h2><code>inv</code></h2>
<p><code>v -- ~v</code></p>
<h4>Description</h4>
<p><code>inv</code> inverts the bits of v.</p>
<h4>Examples</h4>
<pre><code>~0 inv
</code></pre>
<ul>
<li><code>( -- 0)</code></li>
</ul>
<hr />
<h2><code>lsl</code></h2>
<p><code>a b -- (a &lt;&lt; b)</code></p>
<h4>Description</h4>
<p><code>lsl</code> performs a logical shift left. This operation zero-fills.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>hFFFFFFFF 1 lsl
</code></pre>
<ul>
<li><code>( -- hFFFFFFFE)</code></li>
</ul>
<hr />
<h2><code>lsr</code></h2>
<p><code>a b -- (a &gt;&gt; b)</code></p>
<h4>Description</h4>
<p><code>lsr</code> performs a logical shift right. This operation zero-fills.</p>
<h4>Examples</h4>
<pre><code>3 1 lsr
</code></pre>
<ul>
<li><code>( -- 1)</code></li>
</ul>
<hr />
<h2><code>csl</code></h2>
<p><code>a b -- ((a &lt;&lt; b) or (a &gt;&gt; (b - WORD)))</code></p>
<h4>Description</h4>
<p><code>csl</code> performs a circular shift left. Only the amount of bits needed are used for the shift amount. For example, with a 32-bit <code>WORD</code>, only the least significant <code>5</code> bits are masked out of <code>b</code>.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>hC0000000 1 csl
</code></pre>
<ul>
<li><code>( -- h80000001)</code></li>
</ul>
<hr />
<h2><code>csr</code></h2>
<p><code>a b -- ((a &gt;&gt; b) or (a &lt;&lt; (b - WORD)))</code></p>
<h4>Description</h4>
<p><code>csr</code> performs a circular shift right. Only the amount of bits needed are used for the shift amount. For example, with a 32-bit <code>WORD</code>, only the least significant <code>5</code> bits are masked out of <code>b</code>.</p>
<h4>Examples (with WORD of 32)</h4>
<pre><code>3 1 csr
</code></pre>
<ul>
<li><code>( -- h80000001)</code></li>
</ul>
<hr />
<h2><code>and</code></h2>
<p><code>a b -- (a &amp; b)</code></p>
<h4>Description</h4>
<p><code>and</code> finds the binary AND of <code>a</code> and <code>b</code>.</p>
<h4>Examples</h4>
<pre><code>5 4 and
</code></pre>
<ul>
<li><code>( -- 4)</code></li>
</ul>
<hr />
<h2><code>or</code></h2>
<p><code>a b -- (a or b)</code></p>
<h4>Description</h4>
<p><code>or</code> finds the binary OR of <code>a</code> and <code>b</code>.</p>
<h4>Examples</h4>
<pre><code>5 2 or
</code></pre>
<ul>
<li><code>( -- 7)</code></li>
</ul>
<hr />
<h2><code>xor</code></h2>
<p><code>a b -- (a ^ b)</code></p>
<h4>Description</h4>
<p><code>xor</code> finds the binary XOR of <code>a</code> and <code>b</code>.</p>
<h4>Examples</h4>
<pre><code>5 3 xor
</code></pre>
<ul>
<li><code>( -- 6)</code></li>
</ul>
<h1>Stack Manipulation Instructions</h1>
<h2><code>p0</code></h2>
<p><code>-- 0</code></p>
<h4>Description</h4>
<p><code>p0</code> pushes a <code>0</code> onto the top of the stack. This doesn't theoretically need to exist, but it makes it practically easy for the processor to add a <code>0</code> to the stack on inception to receive the data stream from the inceptor. It also has other uses, such as initializing an accumulator value and comparisons with <code>0</code>.</p>
<hr />
<h2><code>dup</code></h2>
<p><code>v -- v v</code></p>
<h4>Description</h4>
<p><code>dup</code> fills a void where <code>copy#</code> cannot, which is copying the top of the stack. Since <code>copy#</code> and <code>rot#</code> address starting from the element directly under the top of stack, this instruction is dedicated to allow copying the top of the stack.</p>
<hr />
<h2><code>rot#</code></h2>
<p><code>v (# + 1).. -- (# + 1).. v</code></p>
<h4>Description</h4>
<p><code>rot#</code> rotates a value <code>1</code> to <code>64</code> elements deep in the stack to the top of the stack. The value is removed from that location and elements under that value are not shifted in the stack.</p>
<h4>Examples</h4>
<pre><code>1 2 3 rot1
</code></pre>
<ul>
<li><code>( -- 2 3 1)</code></li>
</ul>
<hr />
<h2><code>copy#</code></h2>
<p><code>v (# + 1).. -- v (# + 1).. v</code></p>
<h4>Description</h4>
<p><code>copy#</code> copies a value <code>1</code> to <code>64</code> elements deep in the stack to the top of the stack. This pushes all elements down on the stack.</p>
<h4>Examples</h4>
<pre><code>1 2 3 copy1
</code></pre>
<ul>
<li><code>( -- 1 2 3 1)</code></li>
</ul>
<h1>Memory Instructions</h1>
<h2><code>ldi0</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ldi0</code> loads dc0 from the location pointed to by the current dc0. The old dc0 is incremented before being changed and the restored dc0 when returning from this call will be that value. This means that this instruction can be the first instruction of a function which needs a unique dc0.</p>
<hr />
<h2><code>rread#</code></h2>
<p><code>a -- mem[dc# + a]</code></p>
<h4>Description</h4>
<p><code>rread#</code> performs a random read starting from <code>dc#</code> and indexing by <code>a</code>. The result is returned synchronously to the stack because it is assumed that this value is held in the cache, since memory at a dc is generally cached.</p>
<hr />
<h2><code>reads</code></h2>
<p><code>a -- mem[a]</code></p>
<h4>Description</h4>
<p><code>reads</code> performs a synchronous read, meaning that this operation does not complete until the value is on the stack. <code>a</code> is an absolute address.</p>
<hr />
<h2><code>read#</code></h2>
<p><code>-- mem[dc#]</code></p>
<h4>Description</h4>
<p><code>read#</code> performs a read directly at <code>dc#</code>. Doing this increments <code>dc#</code> after the read.</p>
<hr />
<h2><code>get#</code></h2>
<p><code>-- dc#</code></p>
<h4>Description</h4>
<p><code>get#</code> places the address dc# is currently pointing to onto the stack. This allows the programmer to manipulate the dc for allocating memory on a stack or advancing the dc between elements in a vector for use with <code>rread#</code>.</p>
<hr />
<h2><code>write#</code></h2>
<p><code>v --</code></p>
<h4>Description</h4>
<p><code>write#</code> performs a write directly at <code>dc#</code>. Doing this advances <code>dc#</code> depending on how it was set. If it was set with <code>setf</code>, then <code>dc#</code> will write and then increment. If it was set with <code>setb</code>, then <code>dc#</code> will decrement and then write. Due to this behavior, using setb allows a dc to be set up as a pushdown stack.</p>
<hr />
<h2><code>setf#</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>setf#</code> sets <code>dc#</code> to <code>a</code>. It also sets <code>dc#</code> to be in post-increment write mode.</p>
<hr />
<h2><code>setb#</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>setf#</code> sets <code>dc#</code> to <code>a</code>. It also sets <code>dc#</code> to be in pre-decrement write mode.</p>
<hr />
<h2><code>reada</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>reada</code> performs an asynchronous read. This means that the value read will not necessarily complete before the next instruction and the result is not put on the stack. Instead, the value is promised in a slot on the <a href="architecture/conveyor.html">conveyor</a>. When this slot is read from, the read is synchronized and the result is placed on the stack.</p>
<h4>Side Effects</h4>
<ul>
<li><code>cv &lt;- mem[a]</code></li>
</ul>
<h4>Examples</h4>
<pre><code>0 reada
# Do other stuff here
cv0
</code></pre>
<ul>
<li><code>( -- mem[0])</code></li>
<li>Between <code>reada</code> and <code>cv0</code>, any operations happen while the read is occurring.</li>
</ul>
<hr />
<h2><code>rwrite#</code></h2>
<p><code>v a --</code></p>
<h4>Description</h4>
<p><code>rwrite#</code> performs a random write relative to <code>dc#</code>. This means that <code>mem[dc# + a] = v</code>. This may be cached.</p>
<h4>Side Effects</h4>
<ul>
<li><code>mem[dc# + a] = v</code></li>
</ul>
<hr />
<h2><code>write</code></h2>
<p><code>v a --</code></p>
<h4>Description</h4>
<p><code>write</code> performs a random write. This means that <code>mem[a] = v</code>. This may be cached.</p>
<h4>Side Effects</h4>
<ul>
<li><code>mem[a] = v</code></li>
</ul>
<h1>Control Flow</h1>
<h2><code>break</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>break</code> immediately pops the <a href="architecture/lstack.html">lstack</a> and moves the PC to after the loop.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/lstack.html">lstack</a> is popped unconditionally</li>
</ul>
<hr />
<h2><code>continue</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>continue</code> immediately goes to the next loop iteration and moves the PC to the beginning of the loop. If this is the last iteration it goes to the end of the loop.</p>
<h4>Side Effects</h4>
<ul>
<li>Moves PC to beginning of loop normally or after the loop if this is the last iteration</li>
</ul>
<hr />
<h2><code>ret</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ret</code> returns from a subroutine call. It pops the <a href="architecture/cstack.html">cstack</a>, moving the PC and DCs back to the position it was at in the caller to continue execution. This instruction returns from interrupts as well as normal subroutines, since an interrupt is a simulated subroutine call. Using <code>ret</code> in an interrupt also allows more interrupts to be serviced unless they are explicitly disabled in the interrupt.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is popped
<ul>
<li>DCs are returned to their previous values
<ul>
<li>DCs can be modified individually if subroutine doesnt set a new DC, but uses the old one</li>
</ul>
</li>
<li>PC is returned to its previous value</li>
<li>If this is the initial subroutine of an interrupt
<ul>
<li>It is finished servicing</li>
<li>The interrupt <a href="architecture/conveyor.html">conveyor</a> is replaced with the normal <a href="architecture/conveyor.html">conveyor</a></li>
<li>The <code>i</code> bit is set</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>Notes</h4>
<ul>
<li>The <a href="architecture/lstack.html">lstack</a> is NOT returned to its previous state.</li>
</ul>
<h4>Examples</h4>
<pre><code>subr calli
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<pre><code>subr jumpi

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>A more efficient version of the previous example by utilizing tail-call elimination</li>
</ul>
<hr />
<h2><code>calli</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>calli</code> is an immediate call. In this situation, immediate means that the PC to jump to is taken from <code>dc0</code>. This also increments <code>dc0</code> and puts the incremented copy of <code>dc0</code> onto the <a href="architecture/cstack.html">cstack</a>, along with the other state elements preserved in a call.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is pushed
<ul>
<li>DCs are preserved
<ul>
<li>DCs can be modified individually if subroutine doesnt set a new DC, but uses the old one</li>
</ul>
</li>
<li>PC is preserved</li>
<li>Whether an interrupt is being serviced or not is preserved</li>
</ul>
</li>
</ul>
<h4>Examples</h4>
<pre><code>subr calli
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<hr />
<h2><code>jmpi</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jmpi</code> jumps to an immediate value stored at <code>dc0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value</li>
<li><code>dc0</code> is incremented</li>
</ul>
<hr />
<h2><code>jc</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jc</code> jumps to an immediate value stored at <code>dc0</code> if the <code>c</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>c</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jnc</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jnc</code> jumps to an immediate value stored at <code>dc0</code> if the <code>c</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>c</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jo</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jo</code> jumps to an immediate value stored at <code>dc0</code> if the <code>o</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>o</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jno</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jno</code> jumps to an immediate value stored at <code>dc0</code> if the <code>o</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>o</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>ji</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ji</code> jumps to an immediate value stored at <code>dc0</code> if the <code>iflag</code> bit is <code>1</code>. This also increments <code>dc0</code> in the process. To indicate that the interrupt has been seen, <code>iflag</code> is set to <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>iflag</code> is <code>1</code></li>
<li><code>dc0</code> is incremented always</li>
<li><code>iflag</code> is set to <code>0</code></li>
</ul>
<hr />
<h2><code>jni</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>jni</code> jumps to an immediate value stored at <code>dc0</code> if the <code>iflag</code> bit is <code>0</code>. This also increments <code>dc0</code> in the process. To indicate that the interrupt has been seen, <code>iflag</code> is set to <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>iflag</code> is <code>0</code></li>
<li><code>dc0</code> is incremented always</li>
<li><code>iflag</code> is set to <code>0</code></li>
</ul>
<hr />
<h2><code>call</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>call</code> calls a subroutine. The address <code>a</code> is the destination the PC is set to. This pushes the <a href="architecture/cstack.html">cstack</a>, storing all the state elements preserved in a call.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/cstack.html">cstack</a> is pushed
<ul>
<li>DCs are preserved
<ul>
<li>DCs can be modified individually if subroutine doesnt set a new DC, but uses the old one</li>
</ul>
</li>
<li>PC is preserved</li>
<li>Whether an interrupt is being serviced or not is preserved</li>
</ul>
</li>
</ul>
<h4>Examples</h4>
<pre><code>subr read0 call
ret

subr:
  ret
</code></pre>
<ul>
<li><code>( -- )</code></li>
<li>The example calls <code>subr</code> before returning to the original caller</li>
</ul>
<hr />
<h2><code>jmp</code></h2>
<p><code>a --</code></p>
<h4>Description</h4>
<p><code>jmp</code> jumps to the address <code>a</code>.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to <code>a</code></li>
</ul>
<hr />
<h2><code>jeq</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>jeq</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> and <code>b</code> are equal. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a == b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>jne</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>jne</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> and <code>b</code> are not equal. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a != b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>les</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>les</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than <code>b</code> in a signed comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt; b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>leq</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>leq</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in a signed comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lesu</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lesu</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt; b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lequ</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lequ</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>lequ</code></h2>
<p><code>a b --</code></p>
<h4>Description</h4>
<p><code>lequ</code> jumps to an immediate value stored at <code>dc0</code> if <code>a</code> is less than or equal to <code>b</code> in an unsigned comparison. This also increments <code>dc0</code> in the process.</p>
<h4>Side Effects</h4>
<ul>
<li>PC is moved to immediate value if <code>a &lt;= b</code></li>
<li><code>dc0</code> is incremented always</li>
</ul>
<hr />
<h2><code>loop</code></h2>
<p><code>n e --</code></p>
<h4>Description</h4>
<p><code>loop</code> pushes a new loop into onto the <a href="architecture/lstack.html">lstack</a>. <code>n</code> represents the number of iterations of the loop, while <code>e</code> represents the end address of the loop. The loop index (<code>i0</code>) begins at <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/lstack.html">lstack</a> is pushed</li>
</ul>
<hr />
<h2><code>loopi</code></h2>
<p><code>n --</code></p>
<h4>Description</h4>
<p><code>loopi</code> pushes a new loop into onto the <a href="architecture/lstack.html">lstack</a>. <code>n</code> represents the number of iterations of the loop. The end address is taken from <code>dc0</code> and <code>dc0</code> is incremented. The loop index (<code>i0</code>) begins at <code>0</code>.</p>
<h4>Side Effects</h4>
<ul>
<li><a href="architecture/lstack.html">lstack</a> is pushed</li>
<li><code>dc0</code> is incremented</li>
</ul>
<hr />
<h2><code>sef</code></h2>
<p><code>a f --</code></p>
<h4>Description</h4>
<p><code>sef</code> sets the fault handler for a particular fault.</p>
<h4>Side Effects</h4>
<ul>
<li>Future faults of type <code>f</code> will immediately call <code>a</code></li>
</ul>
<h4>Fault types</h4>
<table><thead><tr><td>#</td><td>Name</td><td>Explanation</td></tr></thead>
<tr><td><code>00</code></td><td>Data Stack Overflow</td><td>Triggers when an operation would otherwise have overflowed the <a href="architecture/dstack.html">dstack</a></td></tr>
<tr><td><code>01</code></td><td>Signed Divide by Zero</td><td>Triggers when an operation reads a divide by zero from the <a href="architecture/conveyor.html">conveyor</a></td></tr>
<tr><td><code>02</code></td><td>Unsigned Divide by Zero</td><td>Triggers when an operation reads a divide by zero from the <a href="architecture/conveyor.html">conveyor</a></td></tr>
<tr><td><code>03</code></td><td>Segfault</td><td>Triggers when an operation attempts to read from an invalid memory address and places it on the stack</td></tr>
</table>
<h1>UARC Instructions</h1>
<h2><code>ien</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>ien</code> enables interrupts in the <a href="architecture/ifile.html">ifile</a> only for buses which are presently selected.</p>
<h4>Side Effects</h4>
<ul>
<li>All selected buses now have interrupts enabled.</li>
<li>All non-selected buses now have interrupts disabled.</li>
</ul>
<hr />
<h2><code>recv</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>recv</code> accepts any interrupt synchronously without an interrupt handler from any selected bus. The bus ID (<code>bus</code>) and the interrupt value (<code>v</code>) are added to the <a href="architecture/conveyor.html">conveyor</a> in that order.</p>
<h4>Side Effects</h4>
<ul>
<li><code>cv &lt;- bus, v</code></li>
<li>Synchronizes execution with the next interrupt from a selected bus</li>
<li>Until this receives an interrupt, unselected buses cannot interrupt at all</li>
</ul>
<hr />
<h2><code>kill</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>kill</code> causes every single core connected to every selected bus and every single one of their children to stop before the instruction completes. This instruction takes <code>2 * n</code> cycles, where <code>n</code> is the depth of the longest chain of incepted cores. This will not succeed unless the core has <a href="uarc.html">permission</a> over the target cores. If the target does not have the proper <a href="uarc.html">permission</a>, it will report success without doing anything.</p>
<h4>Side Effects</h4>
<ul>
<li>All selected cores for which this core has permission will be stopped before this instruction finishes.</li>
</ul>
<hr />
<h2><code>wait</code></h2>
<p><code>--</code></p>
<h4>Description</h4>
<p><code>wait</code> allows the code to synchronously handle interrupts by waiting the core until the next interrupt. If an interrupt had already been received, the <code>i</code> will already be <code>1</code>, thus this will immediately continue.</p>
<h4>Side Effects</h4>
<ul>
<li>Synchronizes with the first received interrupt or continues if <code>i</code> is already set.</li>
</ul>
<hr />
<h2><code>getbp</code></h2>
<p><code>b -- perm</code></p>
<h4>Description</h4>
<p><code>getbp</code> places the <a href="uarc.html">permission</a> of the core on bus <code>b</code> onto the stack.</p>
<hr />
<h2><code>getba</code></h2>
<p><code>b -- addr</code></p>
<h4>Description</h4>
<p><code>getba</code> places the <a href="uarc.html">address</a> of the core on bus <code>b</code> onto the stack. If the <code>AND</code> of <code>addr</code> with this core's <a href="uarc.html">permission</a> is equal to this core's <a href="uarc.html">address</a> with the <a href="uarc.html">permission</a> then this core has <a href="uarc.html">privilege</a> over the core on this bus. This check shouldn't need to be performed manually, but that is the process.</p>
<hr />
<h2><code>getp</code></h2>
<p><code>-- perm</code></p>
<h4>Description</h4>
<p><code>getp</code> places the <a href="uarc.html">permission</a> of the current core on the stack. This value is a mask of the <a href="uarc.html">address</a>. The core cannot delegate a <a href="uarc.html">permission</a> on a child core which has any bits unset from its own <a href="uarc.html">permission</a>. Any delegated <a href="uarc.html">address</a> must have the same <a href="uarc.html">address</a> bits which are masked by the delegating core's <a href="uarc.html">permission</a>.</p>
<hr />
<h2><code>geta</code></h2>
<p><code>-- addr</code></p>
<h4>Description</h4>
<p><code>geta</code> places the <a href="uarc.html">address</a> of the current core on the stack. This value is 31 bits and will be placed in the least significant bits of the word. The bits of the <a href="uarc.html">address</a> masked by the <a href="uarc.html">permission</a> must be the same in all child cores.</p>
<h4>Notes</h4>
<ul>
<li>This instruction is not supported for a <code>WORD</code> that is less than 32 bits.</li>
</ul>
<hr />
<h2><code>iset</code></h2>
<p><code>d --</code></p>
<h4>Description</h4>
<p><code>iset</code> sets the interrupt address of all selected UARC buses to the value at <code>mem[dc0]</code> while incrementing the current <code>dc0</code> and also sets the corresponding <code>dc0</code> which is to be immediately set when the interrupt is handled to <code>d</code>. This DC will not be set on a <code>recv</code> instruction.</p>
<h4>Side Effects</h4>
<ul>
<li>Any further interrupts on the selected UARC buses now call the routine at <code>mem[dc0]</code> with a <code>dc0 = d</code>.</li>
</ul>
<hr />
<h2><code>slb</code></h2>
<p><code>b --</code></p>
<h4>Description</h4>
<p><code>slb</code> adds the UARC bus <code>b</code> to the selected cores.</p>
<h4>Side Effects</h4>
<ul>
<li>All UARC calls now also affect <code>b</code>.</li>
</ul>
<hr />
<h2><code>usb</code></h2>
<p><code>b --</code></p>
<h4>Description</h4>
<p><code>usb</code> removes the UARC bus <code>b</code> from the selected cores.</p>
<h4>Side Effects</h4>
<ul>
<li>All UARC calls no longer affect <code>b</code>.</li>
</ul>
<hr />
<h2><code>send</code></h2>
<p><code>v --</code></p>
<h4>Description</h4>
<p><code>send</code> sends a value to all selected UARC buses, and waits for all buses to accept the interrupt before continuing.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the acceptance of all interrupts sent.</li>
</ul>
<hr />
<h2><code>in</code></h2>
<p><code>n a --</code></p>
<h4>Description</h4>
<p><code>in</code> receives a stream from any selected UARC bus. <code>a</code> is the address at which up to <code>n</code> words are to be streamed to. The bus ID of the core that streamed to this core is placed on the conveyor.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the completion of the stream operation.</li>
<li>The bus ID of the sending core is added to the conveyor.</li>
</ul>
<hr />
<h2><code>out</code></h2>
<p><code>n a --</code></p>
<h4>Description</h4>
<p><code>out</code> sends a stream to all selected UARC buses. <code>n</code> is the number of words able to be streamed out and <code>a</code> is the address at which those words are to be streamed from.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the completion of the stream operation.</li>
</ul>
<hr />
<h2><code>incept</code></h2>
<p><code>n a --</code></p>
<h4>Description</h4>
<p><code>incept</code> sends a stream to all selected UARC buses. <code>n</code> is the number of words able to be streamed out and <code>a</code> is the address at which those words are to be streamed from. This will only work on a core which is not presently running or the core has <strong>permission</strong> over the core and the stream will become the instructions to be executed by the target core. By incepting cores again, the system can maintain <strong>permission</strong> over cores allocated on a chip for a process and prevent those cores from incepting cores they aren't supposed to. If a chip is to be given up by the system to a process, the system can incept all cores with the <strong>permission</strong> of the process and run an idle routine.</p>
<h4>Side Effects</h4>
<ul>
<li>Execution is synchronized with the completion of the stream operation.</li>
</ul>
<hr />
<h2><code>set</code></h2>
<p><code>m s --</code></p>
<h4>Description</h4>
<p><code>set</code> clears all buses from being selected and then sets a specific set of UARC buses to be selected. <code>m</code> is a mask for which cores to enable using an <code>OR</code> operation and <code>s</code> is a selector to choose which register to apply the mask to.</p>
<h4>Side Effects</h4>
<ul>
<li>Specific UARC buses are now selected and all others are unselected.</li>
</ul>
<hr />
<h2><code>sel</code></h2>
<p><code>m s --</code></p>
<h4>Description</h4>
<p><code>sel</code> selects a specific set of UARC buses. <code>m</code> is a mask for which cores to enable using an <code>OR</code> operation and <code>s</code> is a selector to choose which register to apply the mask to.</p>
<h4>Side Effects</h4>
<ul>
<li>Specific UARC buses are now added to the selection.</li>
</ul>
<hr />
<h2><code>setp</code></h2>
<p><code>perm addr --</code></p>
<h4>Description</h4>
<p><code>setp</code> sets the <a href="uarc.html">permission</a> that is to be delegated to all incepted UARC cores. This value defaults to the same <a href="uarc.html">permission</a> and <a href="uarc.html">address</a> that this core receives on inception. This instruction will only <code>OR</code> the bits of the old <a href="uarc.html">permission</a> with <code>perm</code>, so it can only restrict the <a href="uarc.html">permission</a>. Any bits from this core's <a href="uarc.html">address</a> which are masked by the <a href="uarc.html">permission</a> will be automatically set the same in the delegation address, while the only bits that will be changed are the ones in <code>addr</code> masked by the inverse of the <a href="uarc.html">permission</a>.</p>
<h4>Side Effects</h4>
<ul>
<li>All cores incepted after this instruction is executed will have the set <a href="uarc.html">permission</a> and <a href="uarc.html">address</a>.</li>
</ul>
<h1>UARC</h1>
<p>c0 is an official UARC ISA. The purpose of UARC is to make it trivial to combine cores that are specialized at performing their function, so as to alleviate the process of providing backwards compatibility and to provide better utilization. The purpose of c0 is somewhat counter to the purpose of UARC: to provide a general purpose architecture. c0 is designed to be an architecture with high instruction density and the capability to quickly respond to communications from other more-specialized cores. To this end its entire architecture is designed, down to the stack architecture that lets it immediately respond to interrupts.</p>
<p>c0, as a reference UARC implementation, must provide all standard UARC facilities. It must allow multicast interrupts and data streaming. It must also allow privilege delegation. Message passing is facilitated by sending words over the UARC bus or sending a stream over the UARC bus. Sending an interrupt to a core that is not running will cause the interrupt to wait for the core to accept the interrupt by starting. Sending a stream to a target that is currently not running will cause permissions to be delegated to that core and for the core to begin running the program streamed to it.</p>
<p>UARC permissions work in a hierarchy. If a core has incepted a core, it also has <strong>privilege</strong> over all the cores incepted by that core. This means that any children cores can be stopped using the <code>kill</code> instruction. Such delegation allows an operating system to not only stop execution of processes, but also delegate permissions to those processes. To achieve this delegation capability, cores continuously share their <strong>permission</strong> and <strong>address</strong> with all targets over the UARC bus so that cores can tell if other cores have <strong>privilege</strong> over them. The only parts of the <strong>address</strong> that are relevant are those masked by the the <strong>permission</strong> of the core. A <strong>permission</strong> of 0 indicates that a core has absolute <strong>privilege</strong> over all cores, including all cores that are of the same privilege level. If the <strong>permission</strong> is all <code>1</code>s, then all <strong>address</strong> bits encode the <strong>privilege</strong> of the core, which means such a core can only <code>kill</code> cores the exact same <strong>address</strong>.</p>
<p>It is permitted for any core to attempt communications with any other core, regardless of either of their <strong>permission</strong>. However, some cores may have specific schemes to accept or reject communications based on a communicating core's delegated <strong>permission</strong>. For instance, a core might have a table of <strong>permission</strong> values that allow it to filter communications based on a core's parents. In c0, such elaborate systems must be implemented in software, but programmers should be aware that other systems might be capable of this.</p>
<p><code>kill</code> is a simple instruction, but it has a complicated result. All child cores of the core being killed must also be killed. To achieve this, the UARC bus has two lines. One line is for sending a kill signal and the other is for acknowledging completion. As soon as a core knows all children are stopped, it may assert the acknowledge line and stop on the next cycle. A core with no children may immediately assert the acknowledge line and stop as soon as possible, since it has already met the above condition. A side effect of this setup is that the kill signal will also take one cycle to propagate down through each core. It takes <code>2 * n</code> cycles to complete the <code>kill</code> instruction, depending on the depth of inception (<code>n</code>).</p>
<p>A corner case is that a core may try to send a kill signal to a core for which it doesn't have <strong>privilege</strong> to kill. In this case, the core should acknowledge immediately without doing anything to prevent deadlock. Also, any core which is already killed should continue to assert the acknowledge line to prevent deadlock in the case that the core is not even running. This also allows cores to know when another core is no longer running, though c0 is not capable of detecting this.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
